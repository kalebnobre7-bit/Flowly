<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#0A84FF">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Flowly">
    <title>Flowly</title>
    <link rel="icon" type="image/svg+xml" href="icon.svg">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon.svg">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root {
            --bg-body: #000000;
            --bg-card: rgba(28, 28, 30, 0.6);
            --bg-card-hover: rgba(44, 44, 46, 0.8);
            --bg-elevated: rgba(44, 44, 46, 1);
            --border-subtle: rgba(255, 255, 255, 0.08);
            --text-primary: #F5F5F7;
            --text-secondary: #86868b;
            --accent-blue: #0A84FF;
            --accent-green: #30D158;
            --accent-orange: #FF9F0A;
            --accent-red: #FF453A;
            --radius-card: 18px;
            --radius-sm: 8px;
        }

        body {
            background-color: var(--bg-body);
            color: var(--text-primary);
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            line-height: 1.5;
            overflow-x: hidden;
            margin: 0;
            padding: 24px;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Navigation */
        .nav-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 32px;
            padding: 0 4px;
        }

        .logo-area {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-img {
            height: 32px;
        }

        .segmented-control {
            background: rgba(118, 118, 128, 0.24);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 2px;
            border-radius: 9px;
            display: flex;
            gap: 1px;
        }

        .segment-btn {
            background: transparent;
            border: none;
            padding: 6px 16px;
            border-radius: 7px;
            color: var(--text-primary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.25, 1, 0.5, 1);
            border: 0.5px solid transparent;
        }

        .segment-btn:hover:not(.active) {
            opacity: 0.8;
        }

        .segment-btn.active {
            background: #636366;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.12), 0 3px 1px rgba(0, 0, 0, 0.04);
            font-weight: 600;
        }

        .utility-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.08);
            border: none;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 16px;
        }

        .utility-btn:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        /* Grid & Cards */
        .day-column {
            background: transparent;
            border-right: 1px solid var(--border-subtle);
            min-height: 70vh;
            padding: 0 16px 32px 16px;
            transition: background 0.2s;
            cursor: text;
        }

        .day-column:last-child {
            border-right: none;
        }

        /* Glass effect for active drag */
        .day-column.drag-over {
            background: rgba(10, 132, 255, 0.05);
            border-radius: 12px;
            border-right-color: transparent;
        }

        h2 {
            font-weight: 700;
            font-size: 17px;
            letter-spacing: -0.02em;
            margin-bottom: 24px;
            opacity: 0.9;
        }

        h3 {
            font-weight: 500;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #6b7280;
            margin-bottom: 8px;
            opacity: 0.6;
        }

        h3.hidden {
            display: none;
        }

        /* Task Items - Notion-style Minimal */
        .task-item {
            background: transparent;
            border: none;
            border-radius: 4px;
            padding: 6px 8px;
            margin-bottom: 2px;
            display: flex;
            align-items: flex-start;
            gap: 8px;
            transition: background 0.15s ease;
            position: relative;
        }

        .task-item:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .task-item.is-habit .task-label {
            color: var(--accent-blue) !important;
        }

        /* Checkbox - Refined */
        .checkbox-custom {
            appearance: none;
            width: 18px;
            height: 18px;
            border: 1.5px solid #555;
            border-radius: 6px;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.02);
            margin-top: 2px;
        }

        .checkbox-custom:hover {
            border-color: #888;
            background: rgba(255, 255, 255, 0.1);
        }

        .checkbox-custom:checked {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            box-shadow: 0 2px 4px rgba(10, 132, 255, 0.3);
        }

        .checkbox-custom:checked::after {
            content: '';
            width: 5px;
            height: 9px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg) translateY(-1px);
        }

        /* Typography & Editing */
        .task-label {
            font-size: 14px;
            line-height: 1.5;
            color: rgba(255, 255, 255, 0.9);
            width: 100%;
            cursor: text;
            transition: opacity 0.2s;
        }

        /* Placeholder para tarefas vazias */
        .task-label[data-placeholder]:empty::before {
            content: attr(data-placeholder);
            color: #666;
            font-style: italic;
        }

        .task-completed {
            color: var(--text-secondary);
            text-decoration: line-through;
            opacity: 0.6;
        }

        .task-label[contenteditable="true"] {
            outline: none;
            background: rgba(10, 132, 255, 0.15);
            border-radius: 4px;
            padding: 0 4px;
            box-shadow: 0 0 0 2px rgba(10, 132, 255, 0.3);
        }

        /* Drag & Drop Visuals */
        .task-drop-zone {
            height: 12px;
            margin: -6px 0;
            position: relative;
            z-index: 5;
            pointer-events: none;
        }

        body.dragging-active .task-drop-zone {
            pointer-events: all;
        }

        .task-drop-zone.show::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 4px;
            right: 4px;
            height: 2px;
            background: var(--accent-blue);
            box-shadow: 0 0 8px var(--accent-blue);
            border-radius: 2px;
            transform: translateY(-50%);
        }

        /* Add Task Button */
        .add-task-btn {
            font-size: 13px;
            color: var(--text-secondary);
            background: rgba(255, 255, 255, 0.03);
            border: 1px dashed var(--border-subtle);
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
            margin-top: 8px;
            opacity: 0.6;
        }

        .add-task-btn:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .task-input {
            background: #1c1c1e;
            border: none;
            border-radius: 8px;
            padding: 10px 12px;
            color: white;
            width: 100%;
            outline: none;
            font-size: 14px;
            box-shadow: 0 0 0 2px transparent;
            transition: box-shadow 0.2s;
        }

        .task-input:focus {
            box-shadow: 0 0 0 2px var(--accent-blue);
        }

        .quick-task-input {
            background: transparent;
            border: none;
            padding: 6px 8px;
            color: white;
            width: 100%;
            outline: none;
            font-size: 14px;
            font-family: inherit;
        }

        .quick-task-input::placeholder {
            color: rgba(255, 255, 255, 0.3);
        }

        .quick-task-container {
            background: transparent;
            border-radius: 4px;
            padding: 0;
            margin-bottom: 2px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.15s ease;
        }

        .quick-task-container:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        /* Floating & Menus */
        .floating-add-btn {
            position: fixed;
            bottom: 32px;
            right: 32px;
            width: 56px;
            height: 56px;
            background: var(--accent-blue);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 24px rgba(10, 132, 255, 0.3);
            cursor: pointer;
            transition: transform 0.2s;
            z-index: 100;
        }

        .floating-add-btn:hover {
            transform: scale(1.08) rotate(90deg);
        }

        /* Botões dos dias da semana no modal */
        .weekly-day-btn {
            flex: 1;
            padding: 10px 0;
            border-radius: 10px;
            border: 1.5px solid #333;
            background: transparent;
            color: #888;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .weekly-day-btn:hover {
            border-color: #0A84FF;
            color: #0A84FF;
        }

        .weekly-day-btn.selected {
            background: #0A84FF;
            border-color: #0A84FF;
            color: white;
        }

        .context-menu {
            position: absolute;
            background: rgba(30, 30, 32, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            padding: 6px;
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.4);
            z-index: 1000;
            display: none;
        }

        .context-menu.show {
            display: flex;
            animation: scaleIn 0.1s ease-out;
        }

        @keyframes scaleIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .toolbar-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.1s;
        }

        .toolbar-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 9999;
        }

        .modal-overlay.show {
            opacity: 1;
            pointer-events: all;
        }

        .modal-content {
            background: #1c1c1e;
            border: 1px solid var(--border-subtle);
            border-radius: 20px;
            padding: 32px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 24px 48px rgba(0, 0, 0, 0.5);
            transform: scale(0.95);
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .modal-overlay.show .modal-content {
            transform: scale(1);
        }

        .btn-primary {
            width: 100%;
            padding: 12px;
            background: var(--accent-blue);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            font-size: 15px;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.1s;
        }

        .btn-primary:active {
            transform: scale(0.98);
            opacity: 0.9;
        }

        .btn-secondary {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 500;
            font-size: 14px;
            cursor: pointer;
            margin-top: 8px;
            transition: background 0.1s;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        /* Color classes */
        .color-default {
            color: #f5f5f7;
        }

        .color-green {
            color: #30d158;
        }

        .color-yellow {
            color: #ffd60a;
        }

        .color-orange {
            color: #ff9f0a;
        }

        .color-red {
            color: #ff453a;
        }

        .drag-handle {
            position: absolute;
            left: -8px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            cursor: pointer;
            color: #555;
            font-size: 12px;
            pointer-events: all;
            z-index: 10;
        }

        .task-item:hover .drag-handle {
            opacity: 1;
        }

        .drag-handle:hover {
            color: #0A84FF;
            transform: translateY(-50%) scale(1.2);
        }

        /* Responsividade */
        @media (max-width: 1024px) {
            body {
                padding: 16px;
            }

            .grid.grid-cols-7 {
                grid-template-columns: repeat(3, 1fr) !important;
            }

            .day-column h2 {
                font-size: 14px;
            }

            .nav-container {
                flex-direction: column;
                gap: 16px;
            }

            .logo-area {
                width: 100%;
                justify-content: center;
            }

            .segmented-control {
                width: 100%;
                overflow-x: auto;
                flex-wrap: nowrap;
            }

            .segment-btn {
                font-size: 11px;
                padding: 5px 12px;
                white-space: nowrap;
            }
        }

        /* Tablets e telas médias */
        @media (max-width: 1024px) {
            body {
                padding: 16px;
            }

            .grid.grid-cols-7 {
                grid-template-columns: repeat(3, 1fr) !important;
                gap: 14px;
            }

            .nav-container {
                margin-bottom: 24px;
            }

            .task-item {
                padding: 12px 14px;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 12px;
            }

            .nav-container {
                flex-direction: column;
                gap: 16px;
                margin-bottom: 20px;
            }

            .logo-area {
                width: 100%;
                justify-content: center;
            }

            .segmented-control {
                width: 100%;
                overflow-x: auto;
                flex-wrap: nowrap;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }

            .segmented-control::-webkit-scrollbar {
                display: none;
            }

            .grid.grid-cols-7 {
                grid-template-columns: 1fr !important;
                gap: 16px;
            }

            .day-column {
                min-height: auto;
                padding: 16px;
            }

            .day-column h2 {
                font-size: 18px;
                margin-bottom: 14px;
                position: sticky;
                top: 0;
                background: var(--bg-card);
                padding: 10px 0;
                z-index: 10;
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
                border-radius: var(--radius-sm);
            }

            .task-item {
                font-size: 14px;
                padding: 14px 16px;
                min-height: 48px;
            }

            .task-label {
                font-size: 14px;
            }

            .checkbox-custom {
                width: 22px !important;
                height: 22px !important;
                min-width: 22px !important;
            }
        }

        /* Landscape mode em smartphones */
        @media (max-width: 768px) and (orientation: landscape) {
            .grid.grid-cols-7 {
                grid-template-columns: repeat(2, 1fr) !important;
            }

            .day-column {
                min-height: auto;
            }
        }


        @media (max-width: 480px) {
            .grid.grid-cols-7 {
                grid-template-columns: 1fr !important;
            }

            .day-column {
                min-height: 150px;
                padding: 12px;
            }

            .day-column h2 {
                font-size: 16px;
                margin-bottom: 12px;
                position: sticky;
                top: 0;
                background: var(--bg-card);
                padding: 8px 0;
                z-index: 10;
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
            }

            .task-item {
                padding: 12px 14px;
                font-size: 13px;
                min-height: 48px;
                /* Touch-friendly */
                gap: 12px;
            }

            .checkbox-custom {
                width: 20px !important;
                height: 20px !important;
                min-width: 20px !important;
            }

            .drag-handle {
                display: none;
            }

            .nav-container {
                gap: 12px;
            }

            .segment-btn {
                font-size: 11px;
                padding: 5px 12px;
                min-height: 36px;
            }

            .logo-img {
                height: 24px;
            }

            /* FAB maior em mobile */
            .fab {
                width: 56px !important;
                height: 56px !important;
                bottom: 16px !important;
                right: 16px !important;
            }

            .fab svg {
                width: 24px;
                height: 24px;
            }

            /* Inputs touch-friendly */
            input[type="text"],
            textarea,
            select {
                font-size: 16px !important;
                /* Previne zoom no iOS */
                padding: 12px !important;
                min-height: 44px;
            }

            /* Drop zones mais visíveis */
            .drop-zone {
                min-height: 48px !important;
                border-width: 2px;
            }

            .drop-zone.active {
                min-height: 56px !important;
                background: rgba(10, 132, 255, 0.15) !important;
            }

            /* Botões touch-friendly */
            .week-nav-btn {
                min-width: 44px;
                min-height: 44px;
                padding: 12px;
            }
        }


        /* Ajuste de largura máxima para telas grandes */
        @media (min-width: 1920px) {
            body {
                max-width: 1800px;
                margin: 0 auto;
            }
        }
    </style>
</head>

<body class="antialiased">
    <div class="max-w-[1400px] mx-auto">
        <!-- Header -->
        <div class="nav-container">
            <div class="logo-area">
                <img src="logo_flowly.png" alt="Flowly" class="logo-img">
            </div>

            <div class="segmented-control">
                <button id="btnMonth" class="segment-btn" onclick="setView('month')">Mês</button>
                <button id="btnWeek" class="segment-btn active" onclick="setView('week')">Semana</button>
                <button id="btnToday" class="segment-btn" onclick="setView('today')">Hoje</button>
                <button id="btnRoutine" class="segment-btn" onclick="setView('routine')">Rotina</button>
                <button id="btnAnalytics" class="segment-btn" onclick="setView('analytics')">Analytics</button>
                <button id="btnSettings" class="segment-btn" onclick="setView('settings')"><i data-lucide="settings"
                        style="width: 16px; height: 16px;"></i></button>
            </div>

            <div class="flex items-center gap-3">
                <button id="btnTogglePeriods" class="utility-btn" title="Mostrar/Ocultar períodos"><i data-lucide="list"
                        style="width: 18px; height: 18px;"></i></button>
                <div class="relative">
                    <button id="btnUser" class="utility-btn"><i data-lucide="user"
                            style="width: 18px; height: 18px;"></i></button>
                    <div id="userDropdown" class="context-menu"
                        style="top: 100%; right: 0; margin-top: 8px; min-width: 180px; display: none; flex-direction: column;">
                        <div id="userEmail" class="p-3 text-xs text-gray-500 border-b border-[#333]">user@email.com
                        </div>
                        <div class="p-2 hover:bg-[#333] cursor-pointer rounded text-sm text-red-400" id="btnLogout">Sair
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Week Navigation -->
        <div id="weekNav" class="hidden flex items-center justify-center gap-4 mb-6">
            <button id="btnPrevWeek" class="utility-btn" onclick="changeWeek(-1)"><i data-lucide="chevron-left"
                    style="width: 18px; height: 18px;"></i></button>
            <div class="text-sm text-gray-400" id="weekLabel">Semana Atual</div>
            <button id="btnNextWeek" class="utility-btn" onclick="changeWeek(1)"><i data-lucide="chevron-right"
                    style="width: 18px; height: 18px;"></i></button>
            <button id="btnCurrentWeek" class="btn-secondary text-xs px-3 py-1 ml-4" onclick="goToCurrentWeek()"
                style="width: auto; padding: 6px 12px;">Semana Atual</button>
        </div>

        <!-- Main Content -->
        <div id="contentArea">
            <div id="monthView" class="hidden"></div>
            <div id="weekGrid" class="grid grid-cols-7 gap-0">
                <!-- Javascript will populate this -->
            </div>
            <div id="routineView" class="hidden"></div>
            <div id="analyticsView" class="hidden"></div>
            <div id="settingsView" class="hidden"></div>
        </div>
    </div>

    <!-- Floating Action Button -->
    <div id="floatingAddBtn" class="floating-add-btn">
        <img src="icon.svg" alt="Flowly" style="width: 34px; height: 34px;">
    </div>

    <!-- Quick Add Menu -->
    <div id="quickAddMenu" class="context-menu"
        style="position: fixed; bottom: 100px; right: 32px; min-width: 200px; flex-direction: column; gap: 4px;">
        <div class="quick-add-option p-2 hover:bg-[#333] rounded cursor-pointer text-sm flex items-center gap-2"
            data-type="routine"><i data-lucide="repeat" style="width: 16px; height: 16px;"></i> Adicionar rotina diária
        </div>
        <div class="quick-add-option p-2 hover:bg-[#333] rounded cursor-pointer text-sm flex items-center gap-2"
            data-type="weekly"><i data-lucide="calendar" style="width: 16px; height: 16px;"></i> Tarefa semanal
            recorrente</div>
        <div class="quick-add-option p-2 hover:bg-[#333] rounded cursor-pointer text-sm flex items-center gap-2"
            data-type="custom"><i data-lucide="plus" style="width: 16px; height: 16px;"></i> Nova tarefa customizada
        </div>
    </div>

    <!-- Modal: Tarefa Semanal Recorrente -->
    <div id="weeklyModal" class="modal-overlay" style="z-index: 9999;">
        <div class="modal-content" style="max-width: 420px;">
            <h2 class="text-xl font-bold mb-1 flex items-center gap-2">
                <i data-lucide="calendar-repeat" style="width: 22px; height: 22px; color: #0A84FF;"></i>
                Tarefa Semanal
            </h2>
            <p class="text-gray-500 text-sm mb-5">Aparece automaticamente nos dias selecionados toda semana</p>

            <input type="text" id="weeklyTaskText" class="task-input mb-5"
                placeholder="Ex: Reunião de equipe, Academia, Inglês..." style="background: rgba(255,255,255,0.05);"
                autocomplete="off">

            <p class="text-xs text-gray-400 mb-3 uppercase tracking-wider font-semibold">Dias da semana</p>
            <div class="flex gap-2 mb-6" style="justify-content: space-between;">
                <button class="weekly-day-btn" data-day="0">Dom</button>
                <button class="weekly-day-btn" data-day="1">Seg</button>
                <button class="weekly-day-btn" data-day="2">Ter</button>
                <button class="weekly-day-btn" data-day="3">Qua</button>
                <button class="weekly-day-btn" data-day="4">Qui</button>
                <button class="weekly-day-btn" data-day="5">Sex</button>
                <button class="weekly-day-btn" data-day="6">Sáb</button>
            </div>

            <button id="btnSaveWeekly" class="btn-primary mb-3">Salvar</button>
            <button id="btnCancelWeekly" class="btn-secondary">Cancelar</button>
        </div>
    </div>

    <!-- Edit Context Menu -->
    <div id="editToolbar" class="context-menu">
        <button class="toolbar-btn" data-action="bold"><i data-lucide="bold"
                style="width: 16px; height: 16px;"></i></button>
        <button class="toolbar-btn" data-action="italic"><i data-lucide="italic"
                style="width: 16px; height: 16px;"></i></button>
        <button class="toolbar-btn" data-action="strikethrough"><i data-lucide="strikethrough"
                style="width: 16px; height: 16px;"></i></button>
        <div style="width: 1px; background: #333; margin: 0 4px;"></div>
        <button class="toolbar-btn" data-action="color"><i data-lucide="palette"
                style="width: 16px; height: 16px;"></i></button>
        <button class="toolbar-btn" data-action="habit"><i data-lucide="repeat"
                style="width: 16px; height: 16px;"></i></button>
        <div style="width: 1px; background: #333; margin: 0 4px;"></div>
        <button class="toolbar-btn" data-action="delete" style="color: var(--accent-red)"><i data-lucide="trash-2"
                style="width: 16px; height: 16px;"></i></button>
    </div>

    <!-- Color Picker -->
    <div id="colorMenu" class="context-menu" style="gap: 6px;">
        <div class="color-swatch w-6 h-6 rounded-full cursor-pointer border-2 border-transparent hover:scale-110 transition-transform"
            style="background: #6b7280;" data-color="default"></div>
        <div class="color-swatch w-6 h-6 rounded-full cursor-pointer border-2 border-transparent hover:scale-110 transition-transform"
            style="background: #30d158;" data-color="green"></div>
        <div class="color-swatch w-6 h-6 rounded-full cursor-pointer border-2 border-transparent hover:scale-110 transition-transform"
            style="background: #ffd60a;" data-color="yellow"></div>
        <div class="color-swatch w-6 h-6 rounded-full cursor-pointer border-2 border-transparent hover:scale-110 transition-transform"
            style="background: #ff9f0a;" data-color="orange"></div>
        <div class="color-swatch w-6 h-6 rounded-full cursor-pointer border-2 border-transparent hover:scale-110 transition-transform"
            style="background: #ff453a;" data-color="red"></div>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal-overlay show">
        <div class="modal-content">
            <div class="text-center mb-6">
                <img src="logo_flowly.png" alt="Flowly" class="h-16 mx-auto mb-4">
                <h2 class="text-2xl font-bold">Bem-vindo</h2>
            </div>

            <div id="authLogin">
                <input type="email" id="loginEmail" class="task-input mb-3" style="background: rgba(0,0,0,0.3);"
                    placeholder="Email" autocomplete="username">
                <input type="password" id="loginPassword" class="task-input mb-4" style="background: rgba(0,0,0,0.3);"
                    placeholder="Senha" autocomplete="current-password">

                <div class="flex items-center gap-2 mb-6">
                    <input type="checkbox" id="keepLoggedIn" class="checkbox-custom" checked>
                    <label for="keepLoggedIn" class="text-sm text-gray-400">Manter conectado</label>
                </div>

                <button id="btnLogin" class="btn-primary">Entrar</button>
                <button id="btnShowSignup" class="btn-secondary">Criar conta</button>
                <div id="authMessage" class="text-center text-xs mt-4 h-4 text-red-400"></div>
            </div>

            <div id="authSignup" style="display:none;">
                <input type="email" id="signupEmail" class="task-input mb-3" style="background: rgba(0,0,0,0.3);"
                    placeholder="Email">
                <input type="password" id="signupPassword" class="task-input mb-6" style="background: rgba(0,0,0,0.3);"
                    placeholder="Senha (mín. 6 caracteres)">
                <button id="btnSignup" class="btn-primary">Cadastrar</button>
                <button id="btnShowLogin" class="btn-secondary">Voltar</button>
            </div>
        </div>
    </div>

    <script>
        // --- Supabase & Storage Logic ---
        const SUPABASE_URL = 'https://cgrosyjtujakkbjjnmml.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNncm9zeWp0dWpha2tiampubW1sIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzEwMTA0NzcsImV4cCI6MjA4NjU4NjQ3N30.MsDw0nSiLF1jHWMuVGRgTT6gNUeK328RvGBo-YcFG1A';
        const { createClient } = window.supabase;

        // Inicializar flowly_persist_session como true por padrão (checkbox vem marcado)
        if (localStorage.getItem('flowly_persist_session') === null) {
            localStorage.setItem('flowly_persist_session', 'true');
        }

        const customStorage = {
            getItem: (key) => {
                const value = localStorage.getItem(key) || sessionStorage.getItem(key);
                console.log('[Storage] getItem:', key, value ? 'found' : 'not found');
                return value;
            },
            setItem: (key, value) => {
                const shouldPersist = localStorage.getItem('flowly_persist_session') !== 'false';
                console.log('[Storage] setItem:', key, 'persist:', shouldPersist);
                if (shouldPersist) {
                    localStorage.setItem(key, value);
                } else {
                    sessionStorage.setItem(key, value);
                }
            },
            removeItem: (key) => {
                console.log('[Storage] removeItem:', key);
                localStorage.removeItem(key);
                sessionStorage.removeItem(key);
            }
        };

        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_KEY, {
            auth: {
                storage: customStorage,
                autoRefreshToken: true,
                persistSession: true,
                detectSessionInUrl: true,
                storageKey: 'flowly-auth'
            }
        });

        // Listener para mudanças de autenticação
        supabaseClient.auth.onAuthStateChange(async (event, session) => {
            console.log('Auth state changed:', event, session);

            // INITIAL_SESSION acontece quando a página carrega com sessão salva
            if (event === 'INITIAL_SESSION' && session) {
                currentUser = session.user;
                document.getElementById('authModal').classList.remove('show');
                document.getElementById('userEmail').textContent = session.user.email;
                await loadDataFromSupabase();
                renderView();
            } else if (event === 'SIGNED_IN' && session) {
                // SIGNED_IN acontece no login manual (já renderiza no signIn)
                currentUser = session.user;
                document.getElementById('authModal').classList.remove('show');
                document.getElementById('userEmail').textContent = session.user.email;
            } else if (event === 'SIGNED_OUT') {
                currentUser = null;
                document.getElementById('authModal').classList.add('show');
            }
        });

        let currentUser = null;
        let currentView = 'week';
        let draggedTask = null;
        let currentEditingTask = null;
        const width = 600;
        let currentWeekOffset = 0; // 0 = semana atual, -1 = semana passada, +1 = próxima semana
        let currentMonthOffset = 0; // 0 = mês atual

        // Data Structures
        let dailyRoutine = JSON.parse(localStorage.getItem('dailyRoutine') || JSON.stringify([
            { text: "Oração e Salmo", completed: false, color: "default", isHabit: true },
            { text: "Venvanse", completed: false, color: "default", isHabit: true },
            { text: "Ler metas e mantra; celular na gaveta", completed: false, color: "default", isHabit: true }
        ]));

        // Tarefas semanais recorrentes: {text, daysOfWeek: [0,1,2...6], color, isHabit}
        let weeklyRecurringTasks = JSON.parse(localStorage.getItem('weeklyRecurringTasks') || '[]');

        // Estrutura expandida: armazena tarefas por data ISO (YYYY-MM-DD) e período
        let allTasksData = JSON.parse(localStorage.getItem('allTasksData') || '{}');

        // Compatibilidade: estrutura antiga para a semana atual
        const weekData = { "Segunda": {}, "Terça": {}, "Quarta": {}, "Quinta": {}, "Sexta": {}, "Sábado": {}, "Domingo": {} };
        let habitsHistory = JSON.parse(localStorage.getItem('habitsHistory') || '{}');

        // Funções auxiliares de data

        // ===== FUNÇÕES DE SALVAMENTO =====
        function saveToLocalStorage() {
            localStorage.setItem('allTasksData', JSON.stringify(allTasksData));
            localStorage.setItem('weeklyRecurringTasks', JSON.stringify(weeklyRecurringTasks));
            localStorage.setItem('dailyRoutine', JSON.stringify(dailyRoutine));
            localStorage.setItem('habitsHistory', JSON.stringify(habitsHistory));
        }

        // ===== DRAG AND DROP =====
        let dragState = {
            sourceDate: null,
            sourcePeriod: null,
            sourceIndex: null,
            taskData: null
        };

        function handleDragStart(e) {
            const el = e.target;
            const dateStr = el.dataset.date;
            const period = el.dataset.period;
            const index = parseInt(el.dataset.index);

            if (index === -1) return; // Tarefas recorrentes não podem ser arrastadas

            const tasksArray = allTasksData[dateStr]?.[period] || [];
            const task = tasksArray[index];

            dragState.sourceDate = dateStr;
            dragState.sourcePeriod = period;
            dragState.sourceIndex = index;
            dragState.taskData = { ...task };

            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', JSON.stringify(dragState));
            el.style.opacity = '0.4';
        }

        function handleDragEnd(e) {
            e.target.style.opacity = '1';
            document.querySelectorAll('.drop-zone').forEach(dz => dz.classList.remove('active'));
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();

            if (!dragState.taskData) return;

            // Determinar período de destino baseado na posição do mouse
            const targetCol = e.currentTarget;
            const targetDate = targetCol.dataset.date;
            const targetPeriod = 'Tarefas'; // Por padrão coloca em "Tarefas"

            // Remover da posição antiga
            const sourceArray = allTasksData[dragState.sourceDate]?.[dragState.sourcePeriod];
            if (sourceArray) {
                sourceArray.splice(dragState.sourceIndex, 1);

                // Limpar período vazio
                if (sourceArray.length === 0) {
                    delete allTasksData[dragState.sourceDate][dragState.sourcePeriod];
                }
            }

            // Adicionar na nova posição
            if (!allTasksData[targetDate]) allTasksData[targetDate] = {};
            if (!allTasksData[targetDate][targetPeriod]) allTasksData[targetDate][targetPeriod] = [];

            allTasksData[targetDate][targetPeriod].push(dragState.taskData);

            // SALVAR!
            saveToLocalStorage();

            // Sincronizar com Supabase
            syncDateToSupabase(dragState.sourceDate);
            if (targetDate !== dragState.sourceDate) {
                syncDateToSupabase(targetDate);
            }

            // Limpar estado
            dragState = {
                sourceDate: null,
                sourcePeriod: null,
                sourceIndex: null,
                taskData: null
            };

            // Re-renderizar
            renderView();
        }

        function createDropZone(day, dateStr, period, index) {
            const dz = document.createElement('div');
            dz.className = 'drop-zone';
            dz.dataset.date = dateStr;
            dz.dataset.period = period;
            dz.dataset.insertAt = index.toString();

            dz.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dz.classList.add('active');
            });

            dz.addEventListener('dragleave', () => {
                dz.classList.remove('active');
            });

            dz.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dz.classList.remove('active');

                if (!dragState.taskData) return;

                const targetDateStr = dateStr;
                const targetPeriod = period;
                let insertAt = parseInt(dz.dataset.insertAt);

                const sourceDateStr = dragState.sourceDate;
                const sourcePeriod = dragState.sourcePeriod;
                const sourceIndex = dragState.sourceIndex;

                // Remover da posição antiga
                const sourceArray = allTasksData[sourceDateStr]?.[sourcePeriod];
                if (sourceArray) {
                    sourceArray.splice(sourceIndex, 1);

                    // Ajustar index se for a mesma lista
                    if (sourceDateStr === targetDateStr && sourcePeriod === targetPeriod && sourceIndex < insertAt) {
                        insertAt--;
                    }

                    // Limpar período vazio
                    if (sourceArray.length === 0) {
                        delete allTasksData[sourceDateStr][sourcePeriod];
                    }
                }

                // Garantir estruturas
                if (!allTasksData[targetDateStr]) allTasksData[targetDateStr] = {};
                if (!allTasksData[targetDateStr][targetPeriod]) allTasksData[targetDateStr][targetPeriod] = [];

                // Inserir na nova posição
                allTasksData[targetDateStr][targetPeriod].splice(insertAt, 0, dragState.taskData);

                // SALVAR!
                saveToLocalStorage();

                // Sincronizar com Supabase
                syncDateToSupabase(sourceDateStr);
                if (targetDateStr !== sourceDateStr) {
                    syncDateToSupabase(targetDateStr);
                }

                // Limpar estado
                dragState = {
                    sourceDate: null,
                    sourcePeriod: null,
                    sourceIndex: null,
                    taskData: null
                };

                // Re-renderizar
                renderView();
            });

            return dz;
        }


        // Retorna a data local no formato YYYY-MM-DD (sem bug de fuso horário UTC)
        function localDateStr(date = new Date()) {
            return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
        }

        function getWeekDates(weekOffset = 0) {
            const today = new Date();
            const currentDay = today.getDay(); // 0 = Domingo
            const diff = currentDay === 0 ? -6 : 1 - currentDay; // Ajustar para segunda-feira

            const monday = new Date(today);
            monday.setDate(today.getDate() + diff + (weekOffset * 7));
            monday.setHours(0, 0, 0, 0);

            const dates = [];
            const dayNames = ['Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado', 'Domingo'];

            for (let i = 0; i < 7; i++) {
                const date = new Date(monday);
                date.setDate(monday.getDate() + i);
                dates.push({
                    name: dayNames[i],
                    date: date,
                    dateStr: localDateStr(date)
                });
            }

            return dates;
        }

        function getMonthDates(monthOffset = 0) {
            const today = new Date();
            const year = today.getFullYear();
            const month = today.getMonth() + monthOffset;

            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);

            return { firstDay, lastDay, month: firstDay.getMonth(), year: firstDay.getFullYear() };
        }

        function getWeekLabel(weekOffset) {
            const dates = getWeekDates(weekOffset);
            const firstDate = dates[0].date;
            const lastDate = dates[6].date;

            if (weekOffset === 0) return 'Semana Atual';

            const format = (d) => d.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short' });
            return `${format(firstDate)} - ${format(lastDate)}`;
        }

        function changeWeek(direction) {
            currentWeekOffset += direction;
            renderView();
        }

        function goToCurrentWeek() {
            currentWeekOffset = 0;
            renderView();
        }

        // --- Core Functions ---

        async function checkAuth() {
            console.log('[Auth] Checking auth...');
            const { data: { session }, error } = await supabaseClient.auth.getSession();
            console.log('[Auth] Session:', session ? 'found' : 'not found', error);

            if (session) {
                console.log('[Auth] User logged in:', session.user.email);
                currentUser = session.user;
                document.getElementById('authModal').classList.remove('show');
                document.getElementById('userEmail').textContent = session.user.email;
                await loadDataFromSupabase();
                renderView();
            } else {
                console.log('[Auth] No session, showing login');
                document.getElementById('authModal').classList.add('show');
            }
        }

        async function signUp(email, password) {
            const { error } = await supabaseClient.auth.signUp({ email, password });
            if (error) { showAuthMessage(error.message); return false; }
            showAuthMessage('Conta criada! Fazendo login...', 'success');
            await signIn(email, password);
            return true;
        }

        async function signIn(email, password) {
            // Salvar preferência de "manter conectado" ANTES do login
            const keepLoggedIn = document.getElementById('keepLoggedIn').checked;
            localStorage.setItem('flowly_persist_session', keepLoggedIn.toString());

            const { data, error } = await supabaseClient.auth.signInWithPassword({ email, password });
            if (error) { showAuthMessage(error.message); return false; }

            currentUser = data.user;
            document.getElementById('authModal').classList.remove('show');
            document.getElementById('userEmail').textContent = data.user.email;
            await migrateLocalDataToSupabase();
            await loadDataFromSupabase();
            renderView(); // Renderizar a view após login
            return true;
        }

        async function signOut() {
            await supabaseClient.auth.signOut();
            currentUser = null;
            document.getElementById('authModal').classList.add('show');
            location.reload();
        }

        function showAuthMessage(msg, type = 'error') {
            const el = document.getElementById('authMessage');
            el.textContent = msg;
            el.style.color = type === 'error' ? '#ff453a' : '#30d158';
        }

        // --- Sync Logic ---

        async function migrateLocalDataToSupabase() {
            if (!currentUser) return;

            // Verificar se já existem dados no Supabase para este usuário
            const { data: existingTasks } = await supabaseClient.from('tasks').select('id').eq('user_id', currentUser.id).limit(1);
            const hasSupabaseData = existingTasks && existingTasks.length > 0;

            // Se já tem dados no Supabase, não sobrescreve (dados da nuvem têm prioridade)
            if (hasSupabaseData) {
                localStorage.removeItem('weekData');
                return;
            }

            // Se não tem dados no Supabase, sobe os dados locais (allTasksData)
            const localTasksData = JSON.parse(localStorage.getItem('allTasksData') || '{}');
            const inserts = [];

            Object.entries(localTasksData).forEach(([dateStr, periods]) => {
                // Só migra datas no formato YYYY-MM-DD (ignora nomes de dias antigos)
                if (!/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) return;
                Object.entries(periods).forEach(([period, tasks]) => {
                    if (Array.isArray(tasks)) {
                        tasks.forEach(task => {
                            if (!task.text) return;
                            inserts.push({
                                user_id: currentUser.id,
                                day: dateStr,
                                period: period,
                                text: task.text,
                                completed: task.completed || false,
                                color: task.color || 'default',
                                is_habit: task.isHabit || false
                            });
                        });
                    }
                });
            });

            if (inserts.length > 0) {
                const { data: inserted } = await supabaseClient.from('tasks').insert(inserts).select();
                // Atualizar supabaseId nas tarefas locais
                if (inserted) {
                    inserted.forEach(row => {
                        const tasks = allTasksData[row.day]?.[row.period];
                        if (tasks) {
                            const match = tasks.find(t => t.text === row.text && !t.supabaseId);
                            if (match) match.supabaseId = row.id;
                        }
                    });
                    localStorage.setItem('allTasksData', JSON.stringify(allTasksData));
                }
            }

            localStorage.removeItem('weekData');
        }

        async function loadDataFromSupabase() {
            if (!currentUser) return;
            const { data: tasks, error } = await supabaseClient.from('tasks').select('*').eq('user_id', currentUser.id).order('created_at', { ascending: true });
            if (tasks && tasks.length > 0) {
                // IDs a deletar do Supabase (apenas datas inválidas)
                const idsToDelete = [];

                // Limpa dados locais e reconstrói a partir do Supabase
                allTasksData = {};
                tasks.forEach(task => {
                    const dateStr = task.day;

                    // Ignorar datas inválidas (ex: nomes de dias antigos como "Segunda")
                    if (!dateStr || !/^\d{4}-\d{2}-\d{2}$/.test(dateStr) || !task.period) {
                        if (task.id) idsToDelete.push(task.id);
                        return;
                    }

                    // Ignorar tarefas sem texto
                    if (!task.text || task.text.trim() === '') {
                        if (task.id) idsToDelete.push(task.id);
                        return;
                    }

                    if (!allTasksData[dateStr]) allTasksData[dateStr] = {};
                    if (!allTasksData[dateStr][task.period]) allTasksData[dateStr][task.period] = [];
                    allTasksData[dateStr][task.period].push({
                        text: task.text,
                        completed: task.completed,
                        color: task.color || 'default',
                        isHabit: task.is_habit,
                        supabaseId: task.id
                    });
                });

                // Deletar apenas registros com dados inválidos
                if (idsToDelete.length > 0) {
                    await supabaseClient.from('tasks').delete().in('id', idsToDelete);
                }

                normalizeAllTasks();
                localStorage.setItem('allTasksData', JSON.stringify(allTasksData));
            }
            const { data: habits } = await supabaseClient.from('habits_history').select('*').eq('user_id', currentUser.id);
            if (habits) {
                habitsHistory = {};
                habits.forEach(h => {
                    if (!habitsHistory[h.habit_name]) habitsHistory[h.habit_name] = {};
                    habitsHistory[h.habit_name][h.date] = h.completed;
                });
            }
        }

        async function syncTaskToSupabase(dateStr, period, task) {
            if (!currentUser) return;
            if (task.supabaseId) {
                await supabaseClient.from('tasks').update({
                    text: task.text,
                    completed: task.completed,
                    color: task.color,
                    is_habit: task.isHabit,
                    updated_at: new Date().toISOString()
                }).eq('id', task.supabaseId);
            } else {
                const { data } = await supabaseClient.from('tasks').insert({
                    user_id: currentUser.id,
                    day: dateStr,
                    period: period,
                    text: task.text,
                    completed: task.completed,
                    color: task.color,
                    is_habit: task.isHabit
                }).select();
                if (data && data[0]) task.supabaseId = data[0].id;
            }
        }

        async function deleteTaskFromSupabase(task) {
            if (!currentUser || !task.supabaseId) return;
            await supabaseClient.from('tasks').delete().eq('id', task.supabaseId);
        }

        async function syncHabitToSupabase(habitText, date, completed) {
            if (!currentUser) return;
            await supabaseClient.from('habits_history').upsert({
                user_id: currentUser.id, habit_name: habitText, date, completed
            }, { onConflict: 'user_id,habit_name,date' });
        }

        let _isSyncingDate = false;

        function saveToLocalStorage() {
            localStorage.setItem('allTasksData', JSON.stringify(allTasksData));
            localStorage.setItem('weekData', JSON.stringify(weekData));
            if (currentUser && !_isSyncingDate) {
                // Trigger sync (apenas tarefas normais, não rotina nem recorrentes)
                Object.entries(allTasksData).forEach(([dateStr, periods]) => {
                    Object.entries(periods).forEach(([period, tasks]) => {
                        if (Array.isArray(tasks)) {
                            tasks.forEach(task => {
                                if (!task.isRoutine && !task.isWeeklyRecurring) {
                                    syncTaskToSupabase(dateStr, period, task);
                                }
                            });
                        }
                    });
                });
            }
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem('weekData');
            if (saved) {
                const savedData = JSON.parse(saved);
                Object.keys(weekData).forEach(day => { if (savedData[day]) weekData[day] = savedData[day]; });
            }
        }

        // --- Render Functions ---

        // --- Habits & Analytics Logic ---

        function getAllHabits() {
            const habits = [], habitMap = new Map();
            const today = localDateStr();
            const days = ['Domingo', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'];
            const todayName = days[new Date().getDay()];
            const dateKey = `${todayName}_${today}`;
            const routineStates = JSON.parse(localStorage.getItem('routineStates') || '{}');

            // Adicionar tarefas da rotina diária
            dailyRoutine.forEach(task => {
                if (task.isHabit && !habitMap.has(task.text)) {
                    const isCompleted = routineStates[task.text] && routineStates[task.text][dateKey] || false;
                    habitMap.set(task.text, {
                        text: task.text,
                        color: task.color,
                        completedToday: isCompleted,
                        isHabit: true
                    });
                }
            });

            // Adicionar outras tarefas marcadas como hábitos
            Object.entries(weekData).forEach(([day, periods]) => {
                Object.entries(periods).forEach(([period, tasks]) => {
                    tasks.forEach(task => {
                        if (task.isHabit && !habitMap.has(task.text)) {
                            habitMap.set(task.text, {
                                text: task.text,
                                color: task.color,
                                completedToday: task.completed,
                                isHabit: true
                            });
                        }
                    });
                });
            });

            return Array.from(habitMap.values());
        }

        function getHabitStreak(habitText) { if (!habitsHistory[habitText]) return 0; const today = new Date(); let streak = 0, currentDate = new Date(today); while (true) { const dateKey = localDateStr(currentDate); if (habitsHistory[habitText][dateKey]) { streak++; currentDate.setDate(currentDate.getDate() - 1); } else { break; } } return streak; }

        function getHabitCompletionRate(habitText, days = 30) { if (!habitsHistory[habitText]) return 0; const today = new Date(); let completed = 0; for (let i = 0; i < days; i++) { const date = new Date(today); date.setDate(date.getDate() - i); const dateKey = localDateStr(date); if (habitsHistory[habitText][dateKey]) { completed++; } } return Math.round((completed / days) * 100); }

        function markHabitCompleted(habitText, completed) { const today = localDateStr(); if (!habitsHistory[habitText]) { habitsHistory[habitText] = {}; } if (completed) { habitsHistory[habitText][today] = true; } else { delete habitsHistory[habitText][today]; } localStorage.setItem('habitsHistory', JSON.stringify(habitsHistory)); syncHabitToSupabase(habitText, today, completed); }

        function toggleHabitToday(habitText, completed) { Object.entries(weekData).forEach(([day, periods]) => { Object.entries(periods).forEach(([period, tasks]) => { tasks.forEach(task => { if (task.isHabit && task.text === habitText) { task.completed = completed; } }) }) }); markHabitCompleted(habitText, completed); saveToLocalStorage(); }

        function removeHabit(habitText) {
            if (!confirm(`Tem certeza que deseja remover "${habitText}" dos hábitos?\n\nIsso irá desmarcar esta tarefa como hábito em todas as ocorrências.`)) return;

            // Remover da rotina diária se existir
            const routineIndex = dailyRoutine.findIndex(t => t.text === habitText);
            if (routineIndex !== -1) {
                dailyRoutine.splice(routineIndex, 1);
                localStorage.setItem('dailyRoutine', JSON.stringify(dailyRoutine));
            }

            // Desmarcar como hábito em todas as tarefas existentes
            Object.entries(allTasksData).forEach(([dateStr, periods]) => {
                Object.entries(periods).forEach(([period, tasks]) => {
                    tasks.forEach(task => {
                        if (task.text === habitText && task.isHabit) {
                            task.isHabit = false;
                        }
                    });
                });
            });

            // Limpar histórico do hábito
            if (habitsHistory[habitText]) {
                delete habitsHistory[habitText];
                localStorage.setItem('habitsHistory', JSON.stringify(habitsHistory));
            }

            saveToLocalStorage();
            if (currentView === 'routine') renderRoutineView();
            setTimeout(() => lucide.createIcons(), 0);
        }

        function renderHabitsView() {
            const view = document.getElementById('habitsView'), habits = getAllHabits();
            if (habits.length === 0) { view.innerHTML = '<div class="text-center py-20"><p class="text-gray-400 text-lg">Nenhum hábito rastreado ainda.</p><p class="text-gray-600 text-sm mt-2">Marque tasks como hábitos no menu de contexto (botão direito).</p></div>'; return; }

            let html = `<div class="max-w-5xl mx-auto"><h2 class="text-3xl font-bold mb-8 text-white flex items-center gap-3"><i data-lucide="repeat" style="width: 28px; height: 28px;"></i> Meus Hábitos</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
            <div class="bg-[#1c1c1e] bg-opacity-60 backdrop-blur-xl border border-white/10 rounded-2xl p-6"><div class="text-gray-400 text-sm mb-1 uppercase tracking-wider font-semibold">Total de Hábitos</div><div class="text-3xl font-bold text-white">${habits.length}</div></div>
            <div class="bg-[#1c1c1e] bg-opacity-60 backdrop-blur-xl border border-white/10 rounded-2xl p-6"><div class="text-gray-400 text-sm mb-1 uppercase tracking-wider font-semibold">Concluídos Hoje</div><div class="text-3xl font-bold text-[#30d158]">${habits.filter(h => h.completedToday).length}</div></div>
            <div class="bg-[#1c1c1e] bg-opacity-60 backdrop-blur-xl border border-white/10 rounded-2xl p-6"><div class="text-gray-400 text-sm mb-1 uppercase tracking-wider font-semibold">Taxa Hoje</div><div class="text-3xl font-bold text-[#0A84FF]">${habits.length > 0 ? Math.round((habits.filter(h => h.completedToday).length / habits.length) * 100) : 0}%</div></div></div><div class="space-y-3">`;

            habits.forEach((habit, index) => {
                const streak = getHabitStreak(habit.text), completionRate = getHabitCompletionRate(habit.text, 30);
                html += `<div class="bg-[#1c1c1e] bg-opacity-40 backdrop-blur-md border border-white/5 rounded-xl p-5 hover:bg-opacity-60 transition-all flex items-center justify-between gap-4 group">
                <div class="flex items-center gap-4 flex-1">
                    <input type="checkbox" class="checkbox-custom mt-1" ${habit.completedToday ? 'checked' : ''} onchange="toggleHabitToday('${habit.text.replace(/'/g, "\\'")}', this.checked)">
                    <div class="flex-1">
                        <div class="color-${habit.color} font-medium text-lg mb-1 group-hover:text-white transition-colors">${habit.text}</div>
                        <div class="flex items-center gap-3 text-xs text-gray-400">
                            ${streak > 0 ? `<span class="px-2 py-0.5 rounded-full bg-orange-500/10 text-orange-400 border border-orange-500/20 font-medium flex items-center gap-1"><i data-lucide="flame" style="width: 14px; height: 14px;"></i> ${streak} dias</span>` : ''}
                            <span>${completionRate}% consistency (30d)</span>
                        </div>
                    </div>
                </div>
                <div class="flex items-center gap-3">
                    <div class="w-32 h-1.5 bg-gray-700/30 rounded-full overflow-hidden flex-shrink-0"><div class="h-full bg-blue-500 rounded-full transition-all duration-500" style="width: ${completionRate}%"></div></div>
                    <button onclick="removeHabit('${habit.text.replace(/'/g, "\\'")}');" class="opacity-0 group-hover:opacity-100 transition-opacity p-2 hover:bg-red-500/20 rounded-lg" title="Remover hábito">
                        <i data-lucide="x" class="text-red-400" style="width: 18px; height: 18px;"></i>
                    </button>
                </div>
                </div>`;
            });
            html += `</div></div>`;
            view.innerHTML = html;
        }

        function renderAnalyticsView() {
            const view = document.getElementById('analyticsView');

            // Calcular dados da semana atual
            const weekDates = getWeekDates(0);
            let totalTasksWeek = 0, completedTasksWeek = 0;
            let totalTasksToday = 0, completedTasksToday = 0;
            const today = localDateStr();

            // Estatísticas por dia da semana
            const dayStats = {};

            // Contar tarefas de toda a semana
            weekDates.forEach(({ name, dateStr }) => {
                const dayTasks = allTasksData[dateStr] || {};
                let dayTotal = 0, dayCompleted = 0;

                Object.values(dayTasks).forEach(tasks => {
                    if (Array.isArray(tasks)) {
                        tasks.forEach(task => {
                            dayTotal++;
                            totalTasksWeek++;
                            if (task.completed) {
                                dayCompleted++;
                                completedTasksWeek++;
                            }

                            if (dateStr === today) {
                                totalTasksToday++;
                                if (task.completed) completedTasksToday++;
                            }
                        });
                    }
                });

                dayStats[name] = { total: dayTotal, completed: dayCompleted };
            });

            // Adicionar rotina diária
            const totalHabits = getAllHabits().length;
            const completedHabitsToday = getAllHabits().filter(h => h.completedToday).length;
            totalTasksToday += dailyRoutine.length;
            completedTasksToday += completedHabitsToday;

            const todayRate = totalTasksToday > 0 ? Math.round((completedTasksToday / totalTasksToday) * 100) : 0;
            const weekRate = totalTasksWeek > 0 ? Math.round((completedTasksWeek / totalTasksWeek) * 100) : 0;
            const habitRate = totalHabits > 0 ? Math.round((completedHabitsToday / totalHabits) * 100) : 0;

            // Calcular streak (dias consecutivos com todas as tarefas completas)
            let currentStreak = 0;
            const checkDate = new Date();
            for (let i = 0; i < 30; i++) {
                const dateStr = localDateStr(checkDate);
                const dayTasks = allTasksData[dateStr] || {};
                let dayTotal = 0;
                let dayCompleted = 0;

                Object.values(dayTasks).forEach(tasks => {
                    if (Array.isArray(tasks)) {
                        dayTotal += tasks.length;
                        dayCompleted += tasks.filter(t => t.completed).length;
                    }
                });

                if (dayTotal > 0 && dayCompleted === dayTotal) {
                    currentStreak++;
                } else if (i > 0 || (i === 0 && dayTotal > 0)) {
                    break;
                }
                checkDate.setDate(checkDate.getDate() - 1);
            }

            let html = `<div class="max-w-6xl mx-auto">
                <h2 class="text-3xl font-bold mb-2 text-white flex items-center gap-3">
                    <i data-lucide="bar-chart-3" style="width: 28px; height: 28px;"></i> Analytics
                </h2>
                <p class="text-gray-400 text-sm mb-8">Acompanhe sua produtividade e evolução</p>

                <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-8">`;

            // Card customizado com cores dinâmicas
            const card = (label, val, sub, gradient = 'from-blue-400 to-indigo-400', icon = '') => {
                return `<div class="bg-[#1c1c1e] bg-opacity-60 backdrop-blur-xl border border-white/10 rounded-2xl p-6">
                    <div class="text-gray-400 text-sm mb-2 uppercase tracking-wider font-semibold">${label}</div>
                    <div class="text-4xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r ${gradient}">${icon}${val}</div>
                    <div class="text-xs text-gray-500 mt-2">${sub}</div>
                </div>`;
            };

            // Cards com cores dinâmicas
            const todayGradient = todayRate >= 70 ? 'from-green-400 to-emerald-400' : todayRate >= 40 ? 'from-orange-400 to-yellow-400' : 'from-red-400 to-pink-400';
            const todayIcon = todayRate >= 70 ? '🔥 ' : todayRate >= 40 ? '⚡ ' : '💤 ';

            // Calcular semana passada para comparação
            const lastWeekDates = getWeekDates(-1);
            let lastWeekTotal = 0, lastWeekCompleted = 0;
            lastWeekDates.forEach(({ dateStr }) => {
                const dayTasks = allTasksData[dateStr] || {};
                Object.values(dayTasks).forEach(tasks => {
                    if (Array.isArray(tasks)) {
                        lastWeekTotal += tasks.length;
                        lastWeekCompleted += tasks.filter(t => t.completed).length;
                    }
                });
            });
            const lastWeekRate = lastWeekTotal > 0 ? Math.round((lastWeekCompleted / lastWeekTotal) * 100) : 0;
            const weekDiff = weekRate - lastWeekRate;
            const weekTrend = weekDiff > 0 ? '📈' : weekDiff < 0 ? '📉' : '➡️';
            const weekCompare = weekDiff !== 0 ? `${weekTrend} ${Math.abs(weekDiff)}% vs semana anterior` : 'Mesmo que semana anterior';

            // Melhor e pior dia
            const dayRates = Object.entries(dayStats).map(([name, stats]) => ({
                name,
                rate: stats.total > 0 ? Math.round((stats.completed / stats.total) * 100) : 0,
                total: stats.total
            })).filter(d => d.total > 0);

            const bestDay = dayRates.reduce((best, day) => day.rate > best.rate ? day : best, { name: '-', rate: 0 });
            const worstDay = dayRates.reduce((worst, day) => day.rate < worst.rate ? day : worst, { name: '-', rate: 100 });

            html += card('Hoje', `${todayIcon}${todayRate}%`, `${completedTasksToday}/${totalTasksToday} tarefas`, todayGradient);
            html += card('Semana', `${weekRate}%`, weekCompare, weekDiff > 0 ? 'from-green-400 to-emerald-400' : weekDiff < 0 ? 'from-red-400 to-pink-400' : 'from-blue-400 to-indigo-400');
            html += card('Hábitos', `${habitRate}%`, `${completedHabitsToday}/${totalHabits} concluídos`, habitRate === 100 && totalHabits > 0 ? 'from-green-400 to-emerald-400' : 'from-purple-400 to-pink-400');
            html += card('Streak', currentStreak > 0 ? `${currentStreak} ${currentStreak === 1 ? 'dia' : 'dias'}` : '0', currentStreak > 0 ? '🔥 Dias perfeitos' : 'Complete 100% hoje!', currentStreak >= 7 ? 'from-orange-400 to-red-400' : 'from-gray-400 to-gray-500');

            html += `</div>

            <!-- Gráficos -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="bg-[#1c1c1e] bg-opacity-60 backdrop-blur-xl border border-white/10 rounded-2xl p-8">
                    <h3 class="text-lg font-semibold mb-6 text-gray-200 flex items-center gap-2">
                        <i data-lucide="calendar-days" style="width: 20px; height: 20px;"></i>
                        Progresso da Semana
                    </h3>
                    <canvas id="weekChart"></canvas>
                </div>
                <div class="bg-[#1c1c1e] bg-opacity-60 backdrop-blur-xl border border-white/10 rounded-2xl p-8">
                    <h3 class="text-lg font-semibold mb-6 text-gray-200 flex items-center gap-2">
                        <i data-lucide="target" style="width: 20px; height: 20px;"></i>
                        Status de Hábitos
                    </h3>
                    <div class="h-64 flex items-center justify-center"><canvas id="habitsChart"></canvas></div>
                </div>
            </div>

            <!-- Gráfico de Progresso Mensal -->
            <div class="mt-6 bg-[#1c1c1e] bg-opacity-60 backdrop-blur-xl border border-white/10 rounded-2xl p-8">
                <div class="flex items-center justify-between mb-6">
                    <h3 class="text-lg font-semibold text-gray-200 flex items-center gap-2">
                        <i data-lucide="trending-up" style="width: 20px; height: 20px;"></i>
                        Progresso do Mês
                    </h3>
                    <span id="monthChartLabel" class="text-sm text-gray-400"></span>
                </div>
                <canvas id="monthChart"></canvas>
            </div>

            <!-- Melhor e Pior Dia da Semana -->
            <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-4">
                <div class="bg-[#1c1c1e] bg-opacity-60 backdrop-blur-xl border border-white/10 rounded-2xl p-6">
                    <h3 class="text-sm font-semibold mb-3 text-gray-400 uppercase tracking-wider flex items-center gap-2">
                        <i data-lucide="trophy" style="width: 16px; height: 16px;"></i>
                        Melhor Dia da Semana
                    </h3>
                    ${bestDay.name !== '-' ? `
                        <div class="flex items-center justify-between">
                            <div class="text-2xl font-bold text-green-400">${bestDay.name}</div>
                            <div class="text-3xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-emerald-400">
                                ${bestDay.rate}%
                            </div>
                        </div>
                        <p class="text-xs text-gray-500 mt-2">Maior taxa de conclusão esta semana</p>
                    ` : '<p class="text-gray-500 text-sm">Aguardando dados...</p>'}
                </div>
                <div class="bg-[#1c1c1e] bg-opacity-60 backdrop-blur-xl border border-white/10 rounded-2xl p-6">
                    <h3 class="text-sm font-semibold mb-3 text-gray-400 uppercase tracking-wider flex items-center gap-2">
                        <i data-lucide="alert-circle" style="width: 16px; height: 16px;"></i>
                        Dia que Precisa de Atenção
                    </h3>
                    ${worstDay.name !== '-' && dayRates.length > 1 ? `
                        <div class="flex items-center justify-between">
                            <div class="text-2xl font-bold text-orange-400">${worstDay.name}</div>
                            <div class="text-3xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-orange-400 to-red-400">
                                ${worstDay.rate}%
                            </div>
                        </div>
                        <p class="text-xs text-gray-500 mt-2">Menor taxa de conclusão esta semana</p>
                    ` : '<p class="text-gray-500 text-sm">Aguardando dados...</p>'}
                </div>
            </div>

            <!-- Ranking de Hábitos -->
            <div class="mt-6 bg-[#1c1c1e] bg-opacity-60 backdrop-blur-xl border border-white/10 rounded-2xl p-6">
                <h3 class="text-lg font-semibold mb-4 text-gray-200 flex items-center gap-2">
                    <i data-lucide="award" style="width: 20px; height: 20px;"></i>
                    Ranking de Hábitos (30 dias)
                </h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    ${(() => {
                    const habits = getAllHabits();
                    const habitRanking = habits.map(h => ({
                        text: h.text,
                        rate: getHabitCompletionRate(h.text, 30),
                        streak: getHabitStreak(h.text)
                    })).sort((a, b) => b.rate - a.rate);

                    if (habitRanking.length === 0) {
                        return '<p class="text-gray-500 text-sm col-span-2">Nenhum hábito rastreado ainda.</p>';
                    }

                    return habitRanking.slice(0, 6).map((habit, index) => {
                        const medal = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `${index + 1}º`;
                        const color = habit.rate >= 80 ? 'text-green-400' : habit.rate >= 60 ? 'text-blue-400' : 'text-gray-400';
                        return `
                                <div class="flex items-center justify-between p-3 bg-white/5 rounded-lg hover:bg-white/10 transition-all">
                                    <div class="flex items-center gap-3 flex-1 min-w-0">
                                        <span class="text-xl">${medal}</span>
                                        <div class="flex-1 min-w-0">
                                            <div class="font-medium truncate">${habit.text}</div>
                                            <div class="text-xs text-gray-500">
                                                ${habit.streak > 0 ? `🔥 ${habit.streak} dias` : 'Sem streak'}
                                            </div>
                                        </div>
                                    </div>
                                    <div class="text-xl font-bold ${color}">${habit.rate}%</div>
                                </div>
                            `;
                    }).join('');
                })()}
                </div>
            </div>

            <!-- Heatmap Mensal -->
            <div class="mt-6 bg-[#1c1c1e] bg-opacity-60 backdrop-blur-xl border border-white/10 rounded-2xl p-6">
                <h3 class="text-lg font-semibold mb-4 text-gray-200 flex items-center gap-2">
                    <i data-lucide="calendar-heart" style="width: 20px; height: 20px;"></i>
                    Heatmap de Produtividade (Últimos 30 Dias)
                </h3>
                <div id="heatmapContainer" class="grid grid-cols-7 gap-2">
                    ${(() => {
                    let heatmapHtml = '';
                    const endDate = new Date();
                    const startDate = new Date();
                    startDate.setDate(endDate.getDate() - 29);

                    const currentDate = new Date(startDate);
                    for (let i = 0; i < 30; i++) {
                        const dateStr = localDateStr(currentDate);
                        const dayTasks = allTasksData[dateStr] || {};
                        let total = 0, completed = 0;

                        Object.values(dayTasks).forEach(tasks => {
                            if (Array.isArray(tasks)) {
                                total += tasks.length;
                                completed += tasks.filter(t => t.completed).length;
                            }
                        });

                        const rate = total > 0 ? Math.round((completed / total) * 100) : 0;
                        const intensity = rate >= 80 ? 'bg-green-500' : rate >= 60 ? 'bg-blue-500' : rate >= 40 ? 'bg-orange-500' : rate > 0 ? 'bg-red-500' : 'bg-gray-700';
                        const dayNum = currentDate.getDate();
                        const isToday = dateStr === localDateStr();

                        heatmapHtml += `
                                <div class="relative group">
                                    <div class="${intensity} ${isToday ? 'ring-2 ring-blue-400' : ''} aspect-square rounded-lg flex items-center justify-center text-xs font-bold hover:scale-110 transition-all cursor-pointer"
                                         title="${dateStr}: ${rate}% (${completed}/${total})">
                                        ${dayNum}
                                    </div>
                                    <div class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-2 py-1 bg-black/90 text-white text-xs rounded opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap pointer-events-none z-10">
                                        ${dateStr}<br>${rate}% (${completed}/${total})
                                    </div>
                                </div>
                            `;

                        currentDate.setDate(currentDate.getDate() + 1);
                    }
                    return heatmapHtml;
                })()}
                </div>
                <div class="mt-4 flex items-center justify-center gap-4 text-xs text-gray-500">
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-gray-700 rounded"></div>
                        <span>Sem dados</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-red-500 rounded"></div>
                        <span>&lt;40%</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-orange-500 rounded"></div>
                        <span>40-60%</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-blue-500 rounded"></div>
                        <span>60-80%</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-green-500 rounded"></div>
                        <span>≥80%</span>
                    </div>
                </div>
            </div>

            <!-- Insights -->
            <div class="mt-6 grid grid-cols-1 md:grid-cols-3 gap-4">
                ${totalTasksToday > 0 && completedTasksToday === totalTasksToday ? `
                    <div class="bg-green-500/10 border border-green-500/20 rounded-xl p-4">
                        <div class="flex items-center gap-2 text-green-400 font-semibold mb-1">
                            <i data-lucide="check-circle" style="width: 18px; height: 18px;"></i>
                            Dia Perfeito!
                        </div>
                        <p class="text-sm text-green-300/80">Você completou todas as tarefas de hoje! 🎉</p>
                    </div>
                ` : ''}
                ${currentStreak >= 3 ? `
                    <div class="bg-orange-500/10 border border-orange-500/20 rounded-xl p-4">
                        <div class="flex items-center gap-2 text-orange-400 font-semibold mb-1">
                            <i data-lucide="flame" style="width: 18px; height: 18px;"></i>
                            Streak Ativo!
                        </div>
                        <p class="text-sm text-orange-300/80">${currentStreak} dias consecutivos! Continue assim!</p>
                    </div>
                ` : ''}
                ${habitRate === 100 && totalHabits > 0 ? `
                    <div class="bg-purple-500/10 border border-purple-500/20 rounded-xl p-4">
                        <div class="flex items-center gap-2 text-purple-400 font-semibold mb-1">
                            <i data-lucide="sparkles" style="width: 18px; height: 18px;"></i>
                            Hábitos 100%
                        </div>
                        <p class="text-sm text-purple-300/80">Todos os hábitos completados hoje!</p>
                    </div>
                ` : ''}
            </div>
            </div>`;

            view.innerHTML = html;

            setTimeout(() => {
                // Gráfico de progresso semanal
                const weekCtx = document.getElementById('weekChart');
                if (weekCtx) {
                    const dayNames = ['Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb', 'Dom'];
                    const dayData = weekDates.map(({ name }) => {
                        const stats = dayStats[name] || { total: 0, completed: 0 };
                        return stats.total > 0 ? Math.round((stats.completed / stats.total) * 100) : 0;
                    });

                    new Chart(weekCtx, {
                        type: 'line',
                        data: {
                            labels: dayNames,
                            datasets: [{
                                label: 'Taxa de Conclusão (%)',
                                data: dayData,
                                borderColor: '#0A84FF',
                                backgroundColor: 'rgba(10, 132, 255, 0.1)',
                                tension: 0.4,
                                fill: true,
                                borderWidth: 2,
                                pointRadius: 4,
                                pointHoverRadius: 6,
                                pointBackgroundColor: '#0A84FF'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: true,
                            plugins: {
                                legend: { display: false }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 100,
                                    grid: { color: 'rgba(255,255,255,0.1)' },
                                    ticks: { color: '#888', callback: (value) => value + '%' }
                                },
                                x: {
                                    grid: { display: false },
                                    ticks: { color: '#888' }
                                }
                            }
                        }
                    });
                }

                // Gráfico de hábitos
                const hCtx = document.getElementById('habitsChart');
                if (hCtx) {
                    new Chart(hCtx, {
                        type: 'doughnut',
                        data: {
                            labels: ['Concluídos', 'Pendentes'],
                            datasets: [{
                                data: [completedHabitsToday, totalHabits - completedHabitsToday],
                                backgroundColor: ['#30d158', '#2c2c2e'],
                                borderWidth: 0
                            }]
                        },
                        options: {
                            cutout: '75%',
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        color: '#9ca3af',
                                        usePointStyle: true,
                                        pointStyle: 'circle',
                                        padding: 15
                                    }
                                }
                            }
                        }
                    });
                }

                // Gráfico de progresso mensal
                const monthCtx = document.getElementById('monthChart');
                if (monthCtx) {
                    const now = new Date();
                    const year = now.getFullYear();
                    const month = now.getMonth();
                    const monthNames = ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho',
                        'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'];
                    const daysInMonth = new Date(year, month + 1, 0).getDate();
                    const todayDay = now.getDate();

                    const monthLabels = [];
                    const monthData = [];
                    const pointColors = [];

                    for (let d = 1; d <= daysInMonth; d++) {
                        monthLabels.push(d);
                        const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
                        const dayTasks = allTasksData[dateStr] || {};
                        let total = 0, completed = 0;
                        Object.values(dayTasks).forEach(tasks => {
                            if (Array.isArray(tasks)) {
                                total += tasks.length;
                                completed += tasks.filter(t => t.completed).length;
                            }
                        });
                        const rate = d <= todayDay ? (total > 0 ? Math.round((completed / total) * 100) : null) : null;
                        monthData.push(rate);
                        if (d === todayDay) pointColors.push('#30D158');
                        else if (rate === null) pointColors.push('transparent');
                        else if (rate >= 80) pointColors.push('#30D158');
                        else if (rate >= 50) pointColors.push('#0A84FF');
                        else pointColors.push('#FF453A');
                    }

                    // Atualiza label do mês
                    const labelEl = document.getElementById('monthChartLabel');
                    if (labelEl) labelEl.textContent = `${monthNames[month]} ${year}`;

                    new Chart(monthCtx, {
                        type: 'line',
                        data: {
                            labels: monthLabels,
                            datasets: [{
                                label: 'Conclusão diária (%)',
                                data: monthData,
                                borderColor: '#0A84FF',
                                backgroundColor: 'rgba(10, 132, 255, 0.08)',
                                tension: 0.35,
                                fill: true,
                                borderWidth: 2.5,
                                pointRadius: monthData.map((v, i) => {
                                    if (v === null) return 0;
                                    return i + 1 === todayDay ? 7 : 4;
                                }),
                                pointHoverRadius: 7,
                                pointBackgroundColor: pointColors,
                                pointBorderColor: pointColors,
                                spanGaps: false
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: true,
                            interaction: { mode: 'index', intersect: false },
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    backgroundColor: 'rgba(0,0,0,0.85)',
                                    titleColor: '#ccc',
                                    bodyColor: '#fff',
                                    callbacks: {
                                        title: (items) => `Dia ${items[0].label}`,
                                        label: (item) => item.raw !== null ? ` ${item.raw}% concluído` : ' Sem dados'
                                    }
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 100,
                                    grid: { color: 'rgba(255,255,255,0.07)' },
                                    ticks: {
                                        color: '#888',
                                        callback: (value) => value + '%',
                                        stepSize: 25
                                    }
                                },
                                x: {
                                    grid: { display: false },
                                    ticks: {
                                        color: '#888',
                                        maxTicksLimit: 15,
                                        callback: function (val, index) {
                                            const day = index + 1;
                                            return day === 1 || day % 5 === 0 || day === daysInMonth ? day : '';
                                        }
                                    }
                                }
                            }
                        }
                    });
                }

                lucide.createIcons();
            }, 100);
        }

        function renderMonth() {
            const view = document.getElementById('monthView');
            const { firstDay, lastDay, month, year } = getMonthDates(currentMonthOffset);

            const monthNames = ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho',
                'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'];

            let html = `
                <div class="max-w-[1400px] mx-auto">
                    <div class="flex items-center justify-center gap-4 mb-6">
                        <button onclick="currentMonthOffset--; renderView();" class="utility-btn">
                            <i data-lucide="chevron-left" style="width: 18px; height: 18px;"></i>
                        </button>
                        <h2 class="text-2xl font-bold text-white min-w-[200px] text-center">
                            ${monthNames[month]} ${year}
                        </h2>
                        <button onclick="currentMonthOffset++; renderView();" class="utility-btn">
                            <i data-lucide="chevron-right" style="width: 18px; height: 18px;"></i>
                        </button>
                        <button onclick="currentMonthOffset = 0; renderView();" class="btn-secondary text-xs px-3 py-1 ml-4" style="width: auto; padding: 6px 12px;">
                            Mês Atual
                        </button>
                    </div>

                    <!-- Cabeçalho dos dias da semana -->
                    <div class="grid grid-cols-7 gap-2 mb-2">
                        <div class="text-center text-xs font-semibold text-gray-500 uppercase">Seg</div>
                        <div class="text-center text-xs font-semibold text-gray-500 uppercase">Ter</div>
                        <div class="text-center text-xs font-semibold text-gray-500 uppercase">Qua</div>
                        <div class="text-center text-xs font-semibold text-gray-500 uppercase">Qui</div>
                        <div class="text-center text-xs font-semibold text-gray-500 uppercase">Sex</div>
                        <div class="text-center text-xs font-semibold text-gray-500 uppercase">Sáb</div>
                        <div class="text-center text-xs font-semibold text-gray-500 uppercase">Dom</div>
                    </div>

                    <!-- Grid do calendário -->
                    <div class="grid grid-cols-7 gap-2">
            `;

            // Calcular o primeiro dia da semana (segunda = 0)
            const firstDayOfWeek = firstDay.getDay() === 0 ? 6 : firstDay.getDay() - 1;

            // Preencher dias vazios antes do primeiro dia
            for (let i = 0; i < firstDayOfWeek; i++) {
                html += `<div class="min-h-[120px] bg-[#1c1c1e] bg-opacity-30 rounded-lg"></div>`;
            }

            // Preencher os dias do mês
            const today = localDateStr();
            for (let day = 1; day <= lastDay.getDate(); day++) {
                const date = new Date(year, month, day);
                const dateStr = localDateStr(date);
                const isToday = dateStr === today;

                const dayTasks = allTasksData[dateStr] || {};
                let totalTasks = 0;
                let completedTasks = 0;

                Object.values(dayTasks).forEach(tasks => {
                    if (Array.isArray(tasks)) {
                        totalTasks += tasks.length;
                        completedTasks += tasks.filter(t => t.completed).length;
                    }
                });

                // Adicionar tarefas da rotina diária
                totalTasks += dailyRoutine.length;
                const routineStates = JSON.parse(localStorage.getItem('routineStates') || '{}');
                const dayNames = ['Domingo', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'];
                const dayName = dayNames[date.getDay()];
                const routineKey = `${dayName}_${dateStr}`;

                dailyRoutine.forEach(task => {
                    if (routineStates[task.text] && routineStates[task.text][routineKey]) {
                        completedTasks++;
                    }
                });

                const completionPercent = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;

                html += `
                    <div class="min-h-[120px] bg-[#1c1c1e] bg-opacity-40 rounded-lg p-3 hover:bg-opacity-60 transition-all cursor-pointer border ${isToday ? 'border-blue-500' : 'border-white/5'}"
                         onclick="goToDate('${dateStr}')">
                        <div class="flex items-center justify-between mb-2">
                            <div class="text-sm font-semibold ${isToday ? 'text-blue-400' : 'text-white'}">${day}</div>
                            ${totalTasks > 0 ? `
                                <div class="text-xs text-gray-500">
                                    ${completedTasks}/${totalTasks}
                                </div>
                            ` : ''}
                        </div>

                        ${totalTasks > 0 ? `
                            <div class="w-full h-1 bg-gray-700/30 rounded-full overflow-hidden mb-2">
                                <div class="h-full bg-blue-500 rounded-full transition-all" style="width: ${completionPercent}%"></div>
                            </div>
                        ` : ''}

                        <div class="text-xs text-gray-600 space-y-1">
                            ${totalTasks === 0 ? '<div class="text-center py-4 text-gray-700">Sem tarefas</div>' : ''}
                        </div>
                    </div>
                `;
            }

            html += `
                    </div>
                </div>
            `;

            view.innerHTML = html;
        }

        function goToDate(dateStr) {
            // Calcular qual semana essa data está
            const targetDate = new Date(dateStr);
            const today = new Date();
            const diffTime = targetDate - today;
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            currentWeekOffset = Math.floor(diffDays / 7);

            // Mudar para view semanal
            setView('week');
        }

        function renderRoutineView() {
            const view = document.getElementById('routineView');
            const today = localDateStr();
            const todayDayOfWeek = new Date().getDay();
            const dayNames = ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb'];
            const dayNamesFull = ['Domingo', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'];

            // Estado de conclusão da rotina hoje
            const routineStates = JSON.parse(localStorage.getItem('routineStates') || '{}');
            const days = ['Domingo', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'];
            const todayName = days[new Date().getDay()];
            const dateKey = `${todayName}_${today}`;

            // Stats de hoje
            const totalToday = dailyRoutine.length + weeklyRecurringTasks.filter(rt => rt.daysOfWeek.includes(todayDayOfWeek)).length;
            let completedToday = dailyRoutine.filter(t => routineStates[t.text]?.[dateKey]).length;
            weeklyRecurringTasks.filter(rt => rt.daysOfWeek.includes(todayDayOfWeek)).forEach(rt => {
                if (routineStates[rt.text]?.[dateKey]) completedToday++;
            });
            const rate = totalToday > 0 ? Math.round((completedToday / totalToday) * 100) : 0;

            let html = `<div class="max-w-3xl mx-auto py-8">
                <h2 class="text-3xl font-bold mb-2 text-white flex items-center gap-3">
                    <i data-lucide="repeat" style="width: 28px; height: 28px;"></i> Rotina
                </h2>
                <p class="text-gray-400 mb-6">Hábitos e tarefas recorrentes do seu dia</p>

                <!-- Progresso de hoje -->
                <div class="bg-[#1c1c1e] bg-opacity-60 backdrop-blur-xl border border-white/10 rounded-2xl p-6 mb-8">
                    <div class="flex items-center justify-between mb-3">
                        <div class="text-sm text-gray-400 uppercase tracking-wider font-semibold">Hoje — ${dayNamesFull[todayDayOfWeek]}</div>
                        <div class="text-2xl font-bold ${rate === 100 ? 'text-green-400' : rate >= 50 ? 'text-blue-400' : 'text-gray-400'}">${rate}%</div>
                    </div>
                    <div class="w-full h-2 bg-gray-700/40 rounded-full overflow-hidden">
                        <div class="h-full rounded-full transition-all duration-500 ${rate === 100 ? 'bg-green-400' : 'bg-blue-500'}" style="width: ${rate}%"></div>
                    </div>
                    <div class="text-xs text-gray-500 mt-2">${completedToday} de ${totalToday} concluídos hoje</div>
                </div>

                <!-- Dashboard de Analytics -->
                <div class="mb-8 space-y-4">
                    <h3 class="text-xl font-semibold text-white mb-4 flex items-center gap-2">
                        <i data-lucide="trending-up" style="width: 20px; height: 20px;"></i>
                        Análise da Rotina
                    </h3>
                    
                    <!-- Cards de Estatísticas -->
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                        <!-- Streak Atual -->
                        <div class="bg-gradient-to-br from-orange-500/20 to-orange-600/10 border border-orange-500/30 rounded-xl p-5">
                            <div class="flex items-center justify-between mb-2">
                                <span class="text-xs font-semibold text-orange-300 uppercase tracking-wide">Sequência Atual</span>
                                <i data-lucide="flame" style="width: 18px; height: 18px; color: #ff9500;"></i>
                            </div>
                            <div class="text-3xl font-bold text-white mb-1" id="currentStreak">-</div>
                            <div class="text-xs text-gray-400">dias consecutivos</div>
                        </div>
                        
                        <!-- Taxa Semanal -->
                        <div class="bg-gradient-to-br from-blue-500/20 to-blue-600/10 border border-blue-500/30 rounded-xl p-5">
                            <div class="flex items-center justify-between mb-2">
                                <span class="text-xs font-semibold text-blue-300 uppercase tracking-wide">Taxa Semanal</span>
                                <i data-lucide="calendar-check" style="width: 18px; height: 18px; color: #0A84FF;"></i>
                            </div>
                            <div class="text-3xl font-bold text-white mb-1" id="weeklyRate">-</div>
                            <div class="text-xs text-gray-400">dos últimos 7 dias</div>
                        </div>
                        
                        <!-- Melhor Dia -->
                        <div class="bg-gradient-to-br from-green-500/20 to-green-600/10 border border-green-500/30 rounded-xl p-5">
                            <div class="flex items-center justify-between mb-2">
                                <span class="text-xs font-semibold text-green-300 uppercase tracking-wide">Melhor Dia</span>
                                <i data-lucide="trophy" style="width: 18px; height: 18px; color: #30d158;"></i>
                            </div>
                            <div class="text-2xl font-bold text-white mb-1" id="bestDay">-</div>
                            <div class="text-xs text-gray-400">da semana</div>
                        </div>
                    </div>
                    
                    <!-- Gráfico de Tendência Semanal -->
                    <div class="bg-[#1c1c1e] bg-opacity-60 backdrop-blur-xl border border-white/10 rounded-2xl p-6">
                        <h4 class="text-sm font-semibold text-gray-300 mb-4 uppercase tracking-wide">Consistência Semanal</h4>
                        <canvas id="routineWeekChart" style="max-height: 200px;"></canvas>
                    </div>
                    
                    <!-- Heatmap Mensal -->
                    <div class="bg-[#1c1c1e] bg-opacity-60 backdrop-blur-xl border border-white/10 rounded-2xl p-6">
                        <h4 class="text-sm font-semibold text-gray-300 mb-4 uppercase tracking-wide">Mapa de Calor - Últimos 30 Dias</h4>
                        <div id="routineHeatmap" class="grid grid-cols-10 gap-2"></div>
                        <div class="flex items-center justify-center gap-4 mt-4 text-xs text-gray-500">
                            <div class="flex items-center gap-1.5">
                                <div class="w-4 h-4 rounded-sm bg-[#2c2c2e]"></div>
                                <span>0%</span>
                            </div>
                            <div class="flex items-center gap-1.5">
                                <div class="w-4 h-4 rounded-sm bg-[#ff453a]"></div>
                                <span>1-40%</span>
                            </div>
                            <div class="flex items-center gap-1.5">
                                <div class="w-4 h-4 rounded-sm bg-[#ff9500]"></div>
                                <span>41-60%</span>
                            </div>
                            <div class="flex items-center gap-1.5">
                                <div class="w-4 h-4 rounded-sm bg-[#0A84FF]"></div>
                                <span>61-80%</span>
                            </div>
                            <div class="flex items-center gap-1.5">
                                <div class="w-4 h-4 rounded-sm bg-[#30d158]"></div>
                                <span>81-100%</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- SEÇÃO: Todos os dias -->
                <div class="mb-8">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-lg font-semibold text-gray-200 flex items-center gap-2">
                            <i data-lucide="sun" style="width: 18px; height: 18px; color: #FF9F0A;"></i>
                            Todos os dias
                        </h3>
                        <span class="text-xs text-gray-500">${dailyRoutine.length} tarefa${dailyRoutine.length !== 1 ? 's' : ''}</span>
                    </div>
                    <div class="space-y-2">`;

            if (dailyRoutine.length === 0) {
                html += `<div class="text-gray-500 text-sm py-4 text-center">Nenhuma tarefa diária ainda</div>`;
            }

            dailyRoutine.forEach((task, index) => {
                const isChecked = !!(routineStates[task.text]?.[dateKey]);
                const streak = getHabitStreak(task.text);
                const rate30 = getHabitCompletionRate(task.text, 30);
                html += `
                    <div class="bg-[#1c1c1e] bg-opacity-60 border border-white/8 rounded-xl p-4 flex items-center justify-between group hover:bg-opacity-80 transition-all">
                        <div class="flex items-center gap-4 flex-1">
                            <input type="checkbox" class="checkbox-custom" ${isChecked ? 'checked' : ''}
                                onchange="toggleRoutineToday('${task.text.replace(/'/g, "\\'")}', this.checked)">
                            <div class="flex-1">
                                <div class="font-medium ${isChecked ? 'line-through text-gray-500' : 'text-white'}">${task.text}</div>
                                <div class="flex items-center gap-3 mt-1 text-xs text-gray-500">
                                    ${streak > 0 ? `<span class="text-orange-400 flex items-center gap-1"><i data-lucide="flame" style="width:12px;height:12px;"></i> ${streak}d streak</span>` : ''}
                                    <span>${rate30}% (30d)</span>
                                </div>
                            </div>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-20 h-1 bg-gray-700/40 rounded-full overflow-hidden">
                                <div class="h-full bg-blue-500 rounded-full" style="width:${rate30}%"></div>
                            </div>
                            <button onclick="deleteRoutineTask(${index})" class="opacity-0 group-hover:opacity-100 transition-opacity p-2 hover:bg-red-500/20 rounded-lg ml-1">
                                <i data-lucide="trash-2" class="text-red-400" style="width: 16px; height: 16px;"></i>
                            </button>
                        </div>
                    </div>`;
            });

            html += `
                    </div>
                    <div id="addRoutineTaskContainer" class="mt-3 border border-dashed border-white/15 rounded-xl p-3 hover:border-blue-500/50 transition-all cursor-pointer text-center text-gray-500 hover:text-gray-300 text-sm flex items-center justify-center gap-2" onclick="showAddRoutineTask()">
                        <i data-lucide="plus" style="width: 16px; height: 16px;"></i> Adicionar tarefa diária
                    </div>
                </div>

                <!-- SEÇÃO: Dias específicos -->
                <div class="mb-8">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-lg font-semibold text-gray-200 flex items-center gap-2">
                            <i data-lucide="calendar-days" style="width: 18px; height: 18px; color: #0A84FF;"></i>
                            Dias específicos
                        </h3>
                        <span class="text-xs text-gray-500">${weeklyRecurringTasks.length} tarefa${weeklyRecurringTasks.length !== 1 ? 's' : ''}</span>
                    </div>
                    <div class="space-y-2">`;

            if (weeklyRecurringTasks.length === 0) {
                html += `<div class="text-gray-500 text-sm py-4 text-center">Nenhuma tarefa semanal ainda</div>`;
            }

            weeklyRecurringTasks.forEach((task, index) => {
                const isActiveToday = task.daysOfWeek.includes(todayDayOfWeek);
                const isChecked = isActiveToday && !!(routineStates[task.text]?.[dateKey]);
                const streak = getHabitStreak(task.text);
                const rate30 = getHabitCompletionRate(task.text, 30);
                const daysLabel = task.daysOfWeek.map(d => dayNames[d]).join(', ');
                html += `
                    <div class="bg-[#1c1c1e] bg-opacity-60 border ${isActiveToday ? 'border-blue-500/20' : 'border-white/8'} rounded-xl p-4 flex items-center justify-between group hover:bg-opacity-80 transition-all">
                        <div class="flex items-center gap-4 flex-1">
                            <input type="checkbox" class="checkbox-custom" ${isChecked ? 'checked' : ''} ${!isActiveToday ? 'disabled style="opacity:0.3"' : ''}
                                onchange="toggleRoutineToday('${task.text.replace(/'/g, "\\'")}', this.checked)">
                            <div class="flex-1">
                                <div class="font-medium ${isChecked ? 'line-through text-gray-500' : isActiveToday ? 'text-white' : 'text-gray-500'}">${task.text}</div>
                                <div class="flex items-center gap-3 mt-1 text-xs">
                                    <span class="${isActiveToday ? 'text-blue-400' : 'text-gray-600'}">${daysLabel}</span>
                                    ${streak > 0 ? `<span class="text-orange-400 flex items-center gap-1"><i data-lucide="flame" style="width:12px;height:12px;"></i> ${streak}d</span>` : ''}
                                    <span class="text-gray-500">${rate30}% (30d)</span>
                                </div>
                            </div>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-20 h-1 bg-gray-700/40 rounded-full overflow-hidden">
                                <div class="h-full bg-blue-500 rounded-full" style="width:${rate30}%"></div>
                            </div>
                            <button onclick="deleteWeeklyRecurringTask(${index})" class="opacity-0 group-hover:opacity-100 transition-opacity p-2 hover:bg-red-500/20 rounded-lg ml-1">
                                <i data-lucide="trash-2" class="text-red-400" style="width: 16px; height: 16px;"></i>
                            </button>
                        </div>
                    </div>`;
            });

            html += `
                    </div>
                    <div class="mt-3 border border-dashed border-white/15 rounded-xl p-3 hover:border-blue-500/50 transition-all cursor-pointer text-center text-gray-500 hover:text-gray-300 text-sm flex items-center justify-center gap-2" onclick="showWeeklyRecurrenceDialog()">
                        <i data-lucide="plus" style="width: 16px; height: 16px;"></i> Adicionar tarefa semanal
                    </div>
                </div>
            </div>`;

            view.innerHTML = html;

            // Calcular estatísticas para o dashboard
            if (dailyRoutine.length > 0) {
                const stats = {
                    currentStreak: 0,
                    weeklyRate: 0,
                    bestDay: 'N/A',
                    weekData: [],
                    heatmapData: []
                };

                // Últimos 7 dias para gráfico semanal
                const dayNames = ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb'];
                const fullDayNames = ['Domingo', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'];
                const today = new Date();

                for (let i = 6; i >= 0; i--) {
                    const date = new Date(today);
                    date.setDate(date.getDate() - i);
                    const dateStr = localDateStr(date);
                    const dayName = dayNames[date.getDay()];
                    const fullDayName = fullDayNames[date.getDay()];
                    const dateKey = `${fullDayName}_${dateStr}`;

                    let completed = 0;
                    let total = dailyRoutine.length;

                    dailyRoutine.forEach(task => {
                        if (routineStates[task.text]?.[dateKey]) {
                            completed++;
                        }
                    });

                    const rate = total > 0 ? Math.round((completed / total) * 100) : 0;
                    stats.weekData.push({ day: dayName, rate });
                }

                // Últimos 30 dias para heatmap
                for (let i = 29; i >= 0; i--) {
                    const date = new Date(today);
                    date.setDate(date.getDate() - i);
                    const dateStr = localDateStr(date);
                    const fullDayName = fullDayNames[date.getDay()];
                    const dateKey = `${fullDayName}_${dateStr}`;

                    let completed = 0;
                    let total = dailyRoutine.length;

                    dailyRoutine.forEach(task => {
                        if (routineStates[task.text]?.[dateKey]) {
                            completed++;
                        }
                    });

                    const rate = total > 0 ? Math.round((completed / total) * 100) : 0;
                    stats.heatmapData.push({ date: dateStr, rate });
                }

                // Calcular streak (dias com ≥80% de conclusão)
                let currentDate = new Date(today);
                while (true) {
                    const dateStr = localDateStr(currentDate);
                    const fullDayName = fullDayNames[currentDate.getDay()];
                    const dateKey = `${fullDayName}_${dateStr}`;

                    let completed = 0;
                    dailyRoutine.forEach(task => {
                        if (routineStates[task.text]?.[dateKey]) completed++;
                    });

                    const rate = dailyRoutine.length > 0 ? (completed / dailyRoutine.length) * 100 : 0;
                    if (rate >= 80) {
                        stats.currentStreak++;
                        currentDate.setDate(currentDate.getDate() - 1);
                    } else {
                        break;
                    }
                }

                // Taxa semanal média
                const weeklySum = stats.weekData.reduce((sum, d) => sum + d.rate, 0);
                stats.weeklyRate = Math.round(weeklySum / stats.weekData.length);

                // Melhor dia da semana (baseado nos últimos 4 ocorrências de cada dia)
                const dayRates = {};
                for (let i = 27; i >= 0; i--) {
                    const date = new Date(today);
                    date.setDate(date.getDate() - i);
                    const dateStr = localDateStr(date);
                    const dayName = dayNames[date.getDay()];
                    const fullDayName = fullDayNames[date.getDay()];
                    const dateKey = `${fullDayName}_${dateStr}`;

                    if (!dayRates[dayName]) dayRates[dayName] = [];

                    let completed = 0;
                    dailyRoutine.forEach(task => {
                        if (routineStates[task.text]?.[dateKey]) completed++;
                    });

                    const rate = dailyRoutine.length > 0 ? (completed / dailyRoutine.length) * 100 : 0;
                    dayRates[dayName].push(rate);
                }

                let maxAvg = 0;
                Object.entries(dayRates).forEach(([day, rates]) => {
                    const avg = rates.reduce((a, b) => a + b, 0) / rates.length;
                    if (avg > maxAvg) {
                        maxAvg = avg;
                        stats.bestDay = day;
                    }
                });

                // Atualizar cards
                setTimeout(() => {
                    const streakEl = document.getElementById('currentStreak');
                    const weeklyRateEl = document.getElementById('weeklyRate');
                    const bestDayEl = document.getElementById('bestDay');

                    if (streakEl) streakEl.textContent = stats.currentStreak;
                    if (weeklyRateEl) weeklyRateEl.textContent = stats.weeklyRate + '%';
                    if (bestDayEl) bestDayEl.textContent = stats.bestDay;

                    // Renderizar gráfico semanal
                    const weekCtx = document.getElementById('routineWeekChart');
                    if (weekCtx && typeof Chart !== 'undefined') {
                        new Chart(weekCtx, {
                            type: 'line',
                            data: {
                                labels: stats.weekData.map(d => d.day),
                                datasets: [{
                                    label: 'Conclusão (%)',
                                    data: stats.weekData.map(d => d.rate),
                                    borderColor: '#0A84FF',
                                    backgroundColor: 'rgba(10, 132, 255, 0.1)',
                                    tension: 0.4,
                                    fill: true,
                                    borderWidth: 3,
                                    pointRadius: 5,
                                    pointHoverRadius: 7,
                                    pointBackgroundColor: '#0A84FF',
                                    pointBorderColor: '#fff',
                                    pointBorderWidth: 2
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: true,
                                plugins: {
                                    legend: { display: false },
                                    tooltip: {
                                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                        padding: 12,
                                        titleFont: { size: 14 },
                                        bodyFont: { size: 13 },
                                        callbacks: {
                                            label: (context) => `Conclusão: ${context.parsed.y}%`
                                        }
                                    }
                                },
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        max: 100,
                                        grid: { color: 'rgba(255,255,255,0.08)' },
                                        ticks: {
                                            color: '#888',
                                            callback: (val) => val + '%',
                                            font: { size: 11 }
                                        }
                                    },
                                    x: {
                                        grid: { display: false },
                                        ticks: {
                                            color: '#888',
                                            font: { size: 11 }
                                        }
                                    }
                                }
                            }
                        });
                    }

                    // Renderizar heatmap
                    const heatmapEl = document.getElementById('routineHeatmap');
                    if (heatmapEl) {
                        heatmapEl.innerHTML = '';
                        stats.heatmapData.forEach(({ date, rate }) => {
                            const cell = document.createElement('div');
                            cell.className = 'aspect-square rounded-md transition-all hover:scale-110 cursor-pointer';
                            cell.style.backgroundColor = rate >= 81 ? '#30d158' :
                                rate >= 61 ? '#0A84FF' :
                                    rate >= 41 ? '#ff9500' :
                                        rate > 0 ? '#ff453a' : '#2c2c2e';
                            cell.title = `${date}: ${rate}%`;
                            heatmapEl.appendChild(cell);
                        });
                    }
                }, 100);
            }

            setTimeout(() => lucide.createIcons(), 0);
        }

        function toggleRoutineToday(text, completed) {
            const today = localDateStr();
            const days = ['Domingo', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'];
            const todayName = days[new Date().getDay()];
            const dateKey = `${todayName}_${today}`;
            const routineStates = JSON.parse(localStorage.getItem('routineStates') || '{}');
            if (!routineStates[text]) routineStates[text] = {};
            if (completed) routineStates[text][dateKey] = true;
            else delete routineStates[text][dateKey];
            localStorage.setItem('routineStates', JSON.stringify(routineStates));
            markHabitCompleted(text, completed);
            renderRoutineView();
            setTimeout(() => lucide.createIcons(), 0);
        }

        function showAddRoutineTask() {
            const container = document.getElementById('addRoutineTaskContainer');
            container.innerHTML = `
                <div class="flex gap-2">
                    <input type="text" id="newRoutineTaskInput" class="task-input flex-1" placeholder="Nome da tarefa..." autofocus>
                    <button onclick="addRoutineTask()" class="btn-primary px-6" style="width: auto;">Adicionar</button>
                    <button onclick="renderRoutineView(); setTimeout(() => lucide.createIcons(), 0);" class="btn-secondary px-4" style="width: auto;">Cancelar</button>
                </div>
            `;
            document.getElementById('newRoutineTaskInput').focus();
            document.getElementById('newRoutineTaskInput').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') addRoutineTask();
                if (e.key === 'Escape') { renderRoutineView(); setTimeout(() => lucide.createIcons(), 0); }
            });
        }

        function addRoutineTask() {
            const input = document.getElementById('newRoutineTaskInput');
            if (!input || !input.value.trim()) return;

            dailyRoutine.push({
                text: input.value.trim(),
                completed: false,
                color: 'default',
                isHabit: true  // Tarefas da rotina são automaticamente hábitos
            });

            localStorage.setItem('dailyRoutine', JSON.stringify(dailyRoutine));
            renderRoutineView();
            setTimeout(() => lucide.createIcons(), 0);
        }

        function deleteRoutineTask(index) {
            if (!confirm('Remover esta tarefa da rotina diária?')) return;
            dailyRoutine.splice(index, 1);
            localStorage.setItem('dailyRoutine', JSON.stringify(dailyRoutine));
            renderRoutineView();
            setTimeout(() => lucide.createIcons(), 0);
        }

        function renderSettingsView() {
            const view = document.getElementById('settingsView');

            // Carregar preferências salvas
            const notifSettings = JSON.parse(localStorage.getItem('flowly_notif_settings') || '{}');
            const notifEnabled = notifSettings.enabled !== false;
            const morningTime = notifSettings.morningTime || '08:00';
            const eveningTime = notifSettings.eveningTime || '21:00';
            const notifPerm = ('Notification' in window) ? Notification.permission : 'unsupported';

            const viewSettings = JSON.parse(localStorage.getItem('flowly_view_settings') || '{}');
            const weekStart = viewSettings.weekStart || 'mon'; // 'mon' | 'sun'
            const showWeekends = viewSettings.showWeekends !== false;

            // Badge de status de notificação
            const permBadge = notifPerm === 'granted'
                ? `<span class="text-xs px-2 py-0.5 rounded-full bg-green-500/15 text-green-400 border border-green-500/25">Ativas</span>`
                : notifPerm === 'denied'
                    ? `<span class="text-xs px-2 py-0.5 rounded-full bg-red-500/15 text-red-400 border border-red-500/25">Bloqueadas</span>`
                    : `<span class="text-xs px-2 py-0.5 rounded-full bg-gray-500/15 text-gray-400 border border-gray-500/25">Não solicitado</span>`;

            const settingRow = (icon, title, desc, control) => `
                <div class="flex items-center justify-between gap-4 py-4 border-b border-white/5 last:border-0">
                    <div class="flex items-center gap-3 flex-1 min-w-0">
                        <div class="w-9 h-9 rounded-xl bg-white/5 flex items-center justify-center flex-shrink-0">
                            <i data-lucide="${icon}" style="width:18px;height:18px;color:#86868b;"></i>
                        </div>
                        <div class="min-w-0">
                            <div class="text-sm font-medium text-white">${title}</div>
                            <div class="text-xs text-gray-500 mt-0.5">${desc}</div>
                        </div>
                    </div>
                    <div class="flex-shrink-0">${control}</div>
                </div>`;

            const toggle = (id, checked) => `
                <button id="${id}" role="switch" aria-checked="${checked}"
                    class="relative w-11 h-6 rounded-full transition-colors duration-200 ${checked ? 'bg-blue-500' : 'bg-gray-600'} focus:outline-none">
                    <span class="absolute top-0.5 left-0.5 w-5 h-5 bg-white rounded-full shadow transition-transform duration-200 ${checked ? 'translate-x-5' : 'translate-x-0'}"></span>
                </button>`;

            const timeInput = (id, val) => `
                <input type="time" id="${id}" value="${val}"
                    class="bg-white/5 border border-white/10 rounded-lg px-3 py-1.5 text-sm text-white focus:outline-none focus:border-blue-500/60 w-28">`;

            const select = (id, options, selected) => `
                <select id="${id}" class="bg-white/5 border border-white/10 rounded-lg px-3 py-1.5 text-sm text-white focus:outline-none focus:border-blue-500/60">
                    ${options.map(o => `<option value="${o.v}" ${selected === o.v ? 'selected' : ''} style="background:#1c1c1e">${o.l}</option>`).join('')}
                </select>`;

            view.innerHTML = `
            <div class="max-w-xl mx-auto py-8 px-1">
                <h2 class="text-2xl font-bold mb-8 text-white flex items-center gap-3">
                    <i data-lucide="settings-2" style="width:26px;height:26px;color:#0A84FF;"></i> Configurações
                </h2>

                <!-- CONTA -->
                <div class="mb-3">
                    <p class="text-xs font-semibold text-gray-500 uppercase tracking-widest mb-2 px-1">Conta</p>
                    <div class="bg-[#1c1c1e]/80 backdrop-blur-xl border border-white/8 rounded-2xl px-5 overflow-hidden">
                        <div class="flex items-center justify-between gap-4 py-4 border-b border-white/5">
                            <div class="flex items-center gap-3">
                                <div class="w-9 h-9 rounded-xl bg-blue-500/15 flex items-center justify-center flex-shrink-0">
                                    <i data-lucide="user" style="width:18px;height:18px;color:#0A84FF;"></i>
                                </div>
                                <div>
                                    <div class="text-sm font-medium text-white">${currentUser ? currentUser.email : 'Não logado'}</div>
                                    <div class="text-xs text-gray-500">Conta Flowly</div>
                                </div>
                            </div>
                        </div>
                        <div class="flex items-center justify-between gap-4 py-4">
                            <div class="flex items-center gap-3">
                                <div class="w-9 h-9 rounded-xl bg-white/5 flex items-center justify-center flex-shrink-0">
                                    <i data-lucide="log-out" style="width:18px;height:18px;color:#86868b;"></i>
                                </div>
                                <div>
                                    <div class="text-sm font-medium text-white">Sair da conta</div>
                                    <div class="text-xs text-gray-500">Você precisará fazer login novamente</div>
                                </div>
                            </div>
                            <button onclick="signOut()" class="text-xs px-4 py-1.5 rounded-lg border border-red-500/30 text-red-400 bg-red-500/10 hover:bg-red-500/20 transition-colors">Sair</button>
                        </div>
                    </div>
                </div>

                <!-- NOTIFICAÇÕES -->
                <div class="mb-3 mt-6">
                    <p class="text-xs font-semibold text-gray-500 uppercase tracking-widest mb-2 px-1">Notificações</p>
                    <div class="bg-[#1c1c1e]/80 backdrop-blur-xl border border-white/8 rounded-2xl px-5 overflow-hidden">
                        <div class="flex items-center justify-between gap-4 py-4 border-b border-white/5">
                            <div class="flex items-center gap-3 flex-1">
                                <div class="w-9 h-9 rounded-xl bg-white/5 flex items-center justify-center flex-shrink-0">
                                    <i data-lucide="bell" style="width:18px;height:18px;color:#86868b;"></i>
                                </div>
                                <div>
                                    <div class="text-sm font-medium text-white flex items-center gap-2">Ativar notificações ${permBadge}</div>
                                    <div class="text-xs text-gray-500 mt-0.5">${notifPerm === 'denied' ? 'Desbloqueie nas configurações do navegador' : 'Lembretes e resumo do dia'}</div>
                                </div>
                            </div>
                            ${toggle('toggleNotif', notifEnabled && notifPerm === 'granted')}
                        </div>
                        ${settingRow('sunrise', 'Lembrete matinal', 'Hora para começar o dia com foco', timeInput('inputMorningTime', morningTime))}
                        ${settingRow('sunset', 'Resumo noturno', 'Receba um resumo do que fez no dia', timeInput('inputEveningTime', eveningTime))}
                    </div>
                    ${notifPerm === 'denied' ? `
                    <p class="text-xs text-red-400/70 mt-2 px-1 flex items-center gap-1">
                        <i data-lucide="alert-circle" style="width:12px;height:12px;"></i>
                        Notificações bloqueadas. Vá em Configurações do navegador → Site → Notificações e permita.
                    </p>` : ''}
                </div>

                <!-- VISUALIZAÇÃO -->
                <div class="mb-3 mt-6">
                    <p class="text-xs font-semibold text-gray-500 uppercase tracking-widest mb-2 px-1">Visualização</p>
                    <div class="bg-[#1c1c1e]/80 backdrop-blur-xl border border-white/8 rounded-2xl px-5 overflow-hidden">
                        ${settingRow('calendar', 'Início da semana', 'Primeiro dia exibido na visão semanal',
                select('selectWeekStart', [{ v: 'mon', l: 'Segunda-feira' }, { v: 'sun', l: 'Domingo' }], weekStart))}
                        ${settingRow('calendar-x', 'Mostrar fins de semana', 'Exibir Sábado e Domingo na semana',
                    toggle('toggleWeekends', showWeekends))}
                    </div>
                </div>

                <!-- DADOS -->
                <div class="mb-3 mt-6">
                    <p class="text-xs font-semibold text-gray-500 uppercase tracking-widest mb-2 px-1">Dados</p>
                    <div class="bg-[#1c1c1e]/80 backdrop-blur-xl border border-white/8 rounded-2xl px-5 overflow-hidden">
                        ${settingRow('download', 'Exportar dados', 'Baixe um backup completo em JSON', `<button id="btnExportSettings" class="text-xs px-4 py-1.5 rounded-lg border border-white/15 text-gray-300 bg-white/5 hover:bg-white/10 transition-colors">Exportar</button>`)}
                        ${settingRow('upload', 'Importar backup', 'Restaure a partir de um arquivo JSON',
                        `<label for="fileImportSettings" class="text-xs px-4 py-1.5 rounded-lg border border-white/15 text-gray-300 bg-white/5 hover:bg-white/10 transition-colors cursor-pointer">Importar</label><input type="file" id="fileImportSettings" accept=".json" class="hidden">`)}
                        ${settingRow('wrench', 'Corrigir banco', 'Remove duplicatas e dados corrompidos',
                            `<button id="btnFixDuplicates" class="text-xs px-4 py-1.5 rounded-lg border border-orange-500/30 text-orange-400 bg-orange-500/10 hover:bg-orange-500/20 transition-colors">Corrigir</button>`)}
                        ${settingRow('trash-2', 'Limpar todos os dados', 'Apaga tudo permanentemente',
                                `<button id="btnClearAllSettings" class="text-xs px-4 py-1.5 rounded-lg border border-red-500/30 text-red-400 bg-red-500/10 hover:bg-red-500/20 transition-colors">Limpar</button>`)}
                    </div>
                </div>

                <!-- VERSÃO -->
                <p class="text-center text-xs text-gray-600 mt-8">Flowly v1.0 · Feito com ☕</p>
            </div>`;

            setTimeout(() => {
                lucide.createIcons();

                // --- Toggle Notificações ---
                document.getElementById('toggleNotif').onclick = async function () {
                    if (notifPerm === 'denied') return;
                    if (notifPerm !== 'granted') {
                        const perm = await Notification.requestPermission();
                        if (perm !== 'granted') { renderSettingsView(); return; }
                        scheduleNotifications();
                        showWelcomeNotification();
                    }
                    const cur = JSON.parse(localStorage.getItem('flowly_notif_settings') || '{}');
                    cur.enabled = !(cur.enabled !== false);
                    localStorage.setItem('flowly_notif_settings', JSON.stringify(cur));
                    renderSettingsView();
                };

                // --- Hora matinal ---
                document.getElementById('inputMorningTime').onchange = function () {
                    const cur = JSON.parse(localStorage.getItem('flowly_notif_settings') || '{}');
                    cur.morningTime = this.value;
                    localStorage.setItem('flowly_notif_settings', JSON.stringify(cur));
                    if (Notification.permission === 'granted') scheduleNotifications();
                };

                // --- Hora noturna ---
                document.getElementById('inputEveningTime').onchange = function () {
                    const cur = JSON.parse(localStorage.getItem('flowly_notif_settings') || '{}');
                    cur.eveningTime = this.value;
                    localStorage.setItem('flowly_notif_settings', JSON.stringify(cur));
                    if (Notification.permission === 'granted') scheduleNotifications();
                };

                // --- Início da semana ---
                document.getElementById('selectWeekStart').onchange = function () {
                    const cur = JSON.parse(localStorage.getItem('flowly_view_settings') || '{}');
                    cur.weekStart = this.value;
                    localStorage.setItem('flowly_view_settings', JSON.stringify(cur));
                };

                // --- Toggle fins de semana ---
                document.getElementById('toggleWeekends').onclick = function () {
                    const cur = JSON.parse(localStorage.getItem('flowly_view_settings') || '{}');
                    cur.showWeekends = !(cur.showWeekends !== false);
                    localStorage.setItem('flowly_view_settings', JSON.stringify(cur));
                    renderSettingsView();
                };

                // --- Exportar ---
                document.getElementById('btnExportSettings').onclick = () => {
                    const backup = { allTasksData, weeklyRecurringTasks, dailyRoutine, habitsHistory, exportedAt: new Date().toISOString() };
                    const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url; a.download = `flowly-backup-${localDateStr()}.json`; a.click();
                    URL.revokeObjectURL(url);
                };

                // --- Importar ---
                document.getElementById('fileImportSettings').onchange = function (e) {
                    const file = e.target.files[0]; if (!file) return;
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        try {
                            const data = JSON.parse(ev.target.result);
                            if (data.allTasksData) { allTasksData = data.allTasksData; localStorage.setItem('allTasksData', JSON.stringify(allTasksData)); }
                            if (data.weeklyRecurringTasks) { weeklyRecurringTasks = data.weeklyRecurringTasks; localStorage.setItem('weeklyRecurringTasks', JSON.stringify(weeklyRecurringTasks)); }
                            if (data.dailyRoutine) { dailyRoutine = data.dailyRoutine; localStorage.setItem('dailyRoutine', JSON.stringify(dailyRoutine)); }
                            if (data.habitsHistory) { habitsHistory = data.habitsHistory; localStorage.setItem('habitsHistory', JSON.stringify(habitsHistory)); }
                            renderView();
                            alert('Backup importado com sucesso!');
                        } catch (error) { alert('Erro ao importar backup: ' + error.message); }
                    };
                    reader.readAsText(file);
                };

                // --- Corrigir banco ---
                document.getElementById('btnFixDuplicates').onclick = async () => {
                    if (!currentUser) { alert('Faça login primeiro!'); return; }
                    if (!confirm('Remove duplicatas e tarefas corrompidas do banco. Continuar?')) return;
                    const btn = document.getElementById('btnFixDuplicates');
                    btn.textContent = 'Limpando...'; btn.disabled = true;
                    try {
                        const { data: allT } = await supabaseClient.from('tasks').select('*').eq('user_id', currentUser.id);
                        if (!allT) { alert('Erro ao buscar dados.'); return; }
                        const wTexts = new Set(weeklyRecurringTasks.map(rt => rt.text));
                        const seen = new Map(); const del = [];
                        allT.forEach(t => {
                            const d = t.day || '';
                            if (!d || !/^\d{4}-\d{2}-\d{2}$/.test(d) || !t.period || !t.text || wTexts.has(t.text)) { del.push(t.id); return; }
                            const k = `${d}|${t.period}|${t.text}`;
                            seen.has(k) ? del.push(t.id) : seen.set(k, t.id);
                        });
                        for (let i = 0; i < del.length; i += 100) await supabaseClient.from('tasks').delete().in('id', del.slice(i, i + 100));
                        allTasksData = {}; localStorage.removeItem('allTasksData');
                        await loadDataFromSupabase(); renderView();
                        alert(`${del.length} registros removidos.`);
                    } catch (e) { alert('Erro: ' + e.message); }
                    finally { btn.textContent = 'Corrigir'; btn.disabled = false; }
                };

                // --- Limpar tudo ---
                document.getElementById('btnClearAllSettings').onclick = async () => {
                    if (!confirm('Apagar TODOS os dados? Isso não pode ser desfeito!')) return;
                    const authKeys = Object.keys(localStorage).filter(k => k.startsWith('sb-') || k === 'flowly_persist_session');
                    const authData = {}; authKeys.forEach(k => authData[k] = localStorage.getItem(k));
                    if (currentUser) {
                        await supabaseClient.from('tasks').delete().eq('user_id', currentUser.id);
                        await supabaseClient.from('habits_history').delete().eq('user_id', currentUser.id);
                    }
                    Object.keys(weekData).forEach(d => weekData[d] = {});
                    allTasksData = {}; habitsHistory = {};
                    localStorage.clear();
                    Object.entries(authData).forEach(([k, v]) => localStorage.setItem(k, v));
                    saveToLocalStorage(); renderView();
                    alert('Dados limpos!');
                };
            }, 0);
        }

        function deleteWeeklyRecurringTask(index) {
            if (!confirm('Remover esta tarefa semanal recorrente?')) return;
            weeklyRecurringTasks.splice(index, 1);
            localStorage.setItem('weeklyRecurringTasks', JSON.stringify(weeklyRecurringTasks));
            renderSettingsView();
        }

        async function deleteEmptyTasks() {
            if (!confirm('Tem certeza que deseja excluir todas as tarefas vazias (sem texto)?\n\nEsta ação não pode ser desfeita!')) return;

            let deletedCount = 0;

            // Percorrer todas as datas
            Object.entries(allTasksData).forEach(([dateStr, periods]) => {
                Object.entries(periods).forEach(([period, tasks]) => {
                    if (Array.isArray(tasks)) {
                        // Filtrar tarefas vazias
                        const beforeLength = tasks.length;
                        const filteredTasks = tasks.filter(task => task.text && task.text.trim() !== '');
                        const afterLength = filteredTasks.length;

                        deletedCount += (beforeLength - afterLength);

                        // Atualizar array
                        allTasksData[dateStr][period] = filteredTasks;

                        // Remover período se ficou vazio
                        if (filteredTasks.length === 0) {
                            delete allTasksData[dateStr][period];
                        }
                    }
                });

                // Remover data se não tem mais períodos
                if (Object.keys(allTasksData[dateStr]).length === 0) {
                    delete allTasksData[dateStr];
                }
            });

            // Deletar tarefas vazias do Supabase
            if (currentUser) {
                try {
                    await supabaseClient
                        .from('tasks')
                        .delete()
                        .eq('user_id', currentUser.id)
                        .or('text.is.null,text.eq.');
                } catch (error) {
                    console.error('Erro ao deletar tarefas vazias do Supabase:', error);
                }
            }

            saveToLocalStorage();
            renderView();

            alert(`${deletedCount} tarefa(s) vazia(s) foram excluídas!`);
        }

        function setView(view) {
            currentView = view;
            document.querySelectorAll('.segment-btn').forEach(btn => btn.classList.remove('active'));
            if (view === 'month') document.getElementById('btnMonth').classList.add('active');
            if (view === 'week') document.getElementById('btnWeek').classList.add('active');
            if (view === 'today') document.getElementById('btnToday').classList.add('active');
            if (view === 'routine') document.getElementById('btnRoutine').classList.add('active');
            if (view === 'analytics') document.getElementById('btnAnalytics').classList.add('active');
            if (view === 'settings') document.getElementById('btnSettings').classList.add('active');
            renderView();
        }

        // Função para mostrar modal de criação de tarefa semanal recorrente
        function showWeeklyRecurrenceDialog() {
            const modal = document.getElementById('weeklyModal');
            document.getElementById('weeklyTaskText').value = '';
            // Limpar seleção de dias
            document.querySelectorAll('.weekly-day-btn').forEach(b => b.classList.remove('selected'));
            modal.classList.add('show');
            setTimeout(() => {
                document.getElementById('weeklyTaskText').focus();
                lucide.createIcons();
            }, 100);
        }

        // Retorna as tarefas recorrentes semanais de um dia (apenas para exibição, sem persistir)
        function getWeeklyRecurringForDay(dateStr, dayOfWeek) {
            // Coletar todos os textos já existentes em qualquer período deste dia
            const existingTexts = new Set();
            Object.values(allTasksData[dateStr] || {}).forEach(tasks => {
                if (Array.isArray(tasks)) tasks.forEach(t => { if (t.text) existingTexts.add(t.text); });
            });
            // Também incluir textos da rotina diária (não ficam em allTasksData)
            dailyRoutine.forEach(t => { if (t.text) existingTexts.add(t.text); });
            return weeklyRecurringTasks
                .filter(rt => rt.daysOfWeek.includes(dayOfWeek) && !existingTexts.has(rt.text))
                .map(rt => ({
                    text: rt.text,
                    completed: false,
                    color: rt.color,
                    isHabit: rt.isHabit,
                    isWeeklyRecurring: true
                }));
        }

        function renderView() {
            // Ocultar todas as views
            document.getElementById('monthView').classList.add('hidden');
            document.getElementById('weekGrid').classList.add('hidden');
            document.getElementById('routineView').classList.add('hidden');
            document.getElementById('analyticsView').classList.add('hidden');
            document.getElementById('settingsView').classList.add('hidden');
            document.getElementById('weekNav').classList.add('hidden');

            // Mostrar navegação de semana apenas na view semanal
            if (currentView === 'week') {
                document.getElementById('weekNav').classList.remove('hidden');
            }

            if (currentView === 'month') {
                document.getElementById('monthView').classList.remove('hidden');
                renderMonth();
            } else if (currentView === 'routine') {
                document.getElementById('routineView').classList.remove('hidden');
                renderRoutineView();
            } else if (currentView === 'analytics') {
                document.getElementById('analyticsView').classList.remove('hidden');
                renderAnalyticsView();
            } else if (currentView === 'settings') {
                document.getElementById('settingsView').classList.remove('hidden');
                renderSettingsView();
            } else {
                document.getElementById('weekGrid').classList.remove('hidden');
                if (currentView === 'week') renderWeek();
                else renderToday();
            }

            // Renderizar ícones após atualizar a view
            setTimeout(() => lucide.createIcons(), 0);
        }

        function renderWeek() {
            const grid = document.getElementById('weekGrid');
            grid.className = 'grid grid-cols-7 gap-0';
            grid.innerHTML = '';

            // Atualizar label da semana
            document.getElementById('weekLabel').textContent = getWeekLabel(currentWeekOffset);

            const weekDates = getWeekDates(currentWeekOffset);

            weekDates.forEach(({ name: day, dateStr }) => {
                // Buscar tarefas para esta data específica
                const dayTasks = allTasksData[dateStr] || {};

                // Coletar tarefas de rotina apenas para exibição (sem persistir)
                // MAS: não mostrar se já existe versão persistida em allTasksData
                const routineTasks = dailyRoutine
                    .filter(routineTask => {
                        // Verificar se existe versão persistida desta tarefa
                        const hasPersisted = Object.values(dayTasks).some(periodTasks =>
                            Array.isArray(periodTasks) && periodTasks.some(t => t.text === routineTask.text)
                        );
                        return !hasPersisted; // Só mostrar se NÃO existe persistida
                    })
                    .map(t => ({
                        ...t,
                        isRoutine: true
                    }));

                // Tarefas recorrentes semanais (só exibição, não persistem)
                const date = new Date(dateStr + 'T12:00:00');
                const recurringTasks = getWeeklyRecurringForDay(dateStr, date.getDay());

                const col = document.createElement('div');
                col.className = 'day-column';
                col.dataset.day = day;
                col.dataset.date = dateStr;
                // Drag Events
                col.addEventListener('dragover', handleDragOver);
                col.addEventListener('drop', handleDrop);

                const header = document.createElement('h2');
                header.textContent = day;
                col.appendChild(header);

                // Flatten all tasks from all periods into a continuous list
                const allTasks = [];

                // Adicionar tarefas de rotina no início (apenas para exibição, index = -1 para não serem arrastáveis)
                routineTasks.forEach((task) => {
                    allTasks.push({ task, day, dateStr, period: 'Rotina', originalIndex: -1 });
                });

                // Adicionar tarefas normais salvas (excluindo 'Rotina' se foi persistida indevidamente)
                Object.entries(dayTasks).forEach(([period, tasks]) => {
                    if (period === 'Rotina') return; // Pular tarefas de rotina persistidas indevidamente
                    tasks.forEach((task, index) => {
                        allTasks.push({ task, day, dateStr, period, originalIndex: index });
                    });
                });

                // Adicionar recorrentes semanais no final (não persistidas)
                recurringTasks.forEach((task) => {
                    allTasks.push({ task, day, dateStr, period: 'Tarefas', originalIndex: -1 });
                });

                // ===== ORDENAR TAREFAS POR PRIORIDADE =====
                allTasks.sort((a, b) => {
                    const taskA = a.task;
                    const taskB = b.task;

                    // Função para determinar prioridade da cor
                    const getColorPriority = (task) => {
                        const color = task.color || 'default';
                        if (task.isRoutine || color === 'blue') return 1; // Azuis (rotina) no topo
                        if (color === 'red') return 2; // Vermelhas
                        if (color === 'orange') return 3; // Laranjas
                        if (color === 'green') return 4; // Verdes
                        return 5; // Outras cores
                    };

                    // Primeiro: ordenar por completado (completadas primeiro, não completadas embaixo)
                    if (taskA.completed !== taskB.completed) {
                        return taskA.completed ? -1 : 1;
                    }

                    // Segundo: ordenar por cor/prioridade
                    const priorityA = getColorPriority(taskA);
                    const priorityB = getColorPriority(taskB);

                    return priorityA - priorityB;
                });

                // Render all tasks in sequence without period sections
                allTasks.forEach(({ task, day, dateStr, period, originalIndex }) => {
                    col.appendChild(createTaskElement(day, dateStr, period, task, originalIndex));
                });

                // ===== DROP ZONE NO FINAL DA LISTA =====
                const finalDropZone = document.createElement('div');
                finalDropZone.className = 'drop-zone';
                finalDropZone.dataset.date = dateStr;
                finalDropZone.dataset.period = 'Tarefas';
                finalDropZone.dataset.insertAt = '999999'; // Número alto para indicar "final"
                finalDropZone.style.minHeight = '40px';
                finalDropZone.style.marginTop = '8px';

                finalDropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    finalDropZone.classList.add('active');
                });

                finalDropZone.addEventListener('dragleave', () => {
                    finalDropZone.classList.remove('active');
                });

                finalDropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    finalDropZone.classList.remove('active');

                    if (!dragState.taskData) return;

                    const targetDateStr = dateStr;
                    const targetPeriod = 'Tarefas';

                    const sourceDateStr = dragState.sourceDate;
                    const sourcePeriod = dragState.sourcePeriod;
                    const sourceIndex = dragState.sourceIndex;

                    // Remover da posição antiga
                    const sourceArray = allTasksData[sourceDateStr]?.[sourcePeriod];
                    if (sourceArray) {
                        sourceArray.splice(sourceIndex, 1);

                        // Limpar período vazio
                        if (sourceArray.length === 0) {
                            delete allTasksData[sourceDateStr][sourcePeriod];
                        }
                    }

                    // Garantir estruturas
                    if (!allTasksData[targetDateStr]) allTasksData[targetDateStr] = {};
                    if (!allTasksData[targetDateStr][targetPeriod]) allTasksData[targetDateStr][targetPeriod] = [];

                    // Inserir no FINAL
                    allTasksData[targetDateStr][targetPeriod].push(dragState.taskData);

                    // SALVAR!
                    saveToLocalStorage();

                    // Sincronizar com Supabase
                    syncDateToSupabase(sourceDateStr);
                    if (targetDateStr !== sourceDateStr) {
                        syncDateToSupabase(targetDateStr);
                    }

                    // Limpar estado
                    dragState = {
                        sourceDate: null,
                        sourcePeriod: null,
                        sourceIndex: null,
                        taskData: null
                    };

                    // Re-renderizar
                    renderView();
                });

                col.appendChild(finalDropZone);

                // Adicionar área clicável para nova tarefa (estilo Notion)
                col.addEventListener('click', (e) => {
                    // Só adicionar se clicar na área vazia (não em tasks ou inputs existentes)
                    if (e.target === col || e.target.tagName === 'H2' || e.target.tagName === 'H3') {
                        addQuickTaskInput(col, day);
                    }
                });

                grid.appendChild(col);
            });
        }

        function renderToday() {
            const grid = document.getElementById('weekGrid');
            grid.className = 'max-w-2xl mx-auto';
            grid.innerHTML = '';

            const days = ['Domingo', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'];
            const today = days[new Date().getDay()];
            const dateStr = localDateStr();

            const header = document.createElement('div');
            header.className = 'mb-8';
            header.innerHTML = `<h1 class="text-3xl font-bold mb-2">${today}</h1><p class="text-gray-500">${new Date().toLocaleDateString('pt-BR')}</p>`;
            grid.appendChild(header);

            // Buscar tarefas de hoje
            const dayTasks = allTasksData[dateStr] || {};

            // Coletar tarefas de rotina apenas para exibição (sem persistir)
            const routineTasks = dailyRoutine.map(t => ({
                ...t,
                isRoutine: true
            }));

            // Tarefas recorrentes semanais (só exibição, não persistem)
            const recurringTasks = getWeeklyRecurringForDay(dateStr, new Date().getDay());

            // Flatten all tasks into a continuous list
            const allTasks = [];

            // Adicionar tarefas de rotina no início (apenas para exibição, index = -1 para não serem arrastáveis)
            routineTasks.forEach((task) => {
                allTasks.push({ task, day: today, dateStr, period: 'Rotina', originalIndex: -1 });
            });

            // Adicionar tarefas normais salvas (excluindo 'Rotina' se foi persistida indevidamente)
            Object.entries(dayTasks).forEach(([period, tasks]) => {
                if (period === 'Rotina') return; // Pular tarefas de rotina persistidas indevidamente
                tasks.forEach((task, index) => {
                    allTasks.push({ task, day: today, dateStr, period, originalIndex: index });
                });
            });

            // Adicionar recorrentes semanais no final (não persistidas)
            recurringTasks.forEach((task) => {
                allTasks.push({ task, day: today, dateStr, period: 'Tarefas', originalIndex: -1 });
            });

            // Render all tasks in a single continuous list
            allTasks.forEach(({ task, day, dateStr, period, originalIndex }) => {
                grid.appendChild(createTaskElement(day, dateStr, period, task, originalIndex));
            });

            // Adicionar área clicável para nova tarefa (estilo Notion)
            grid.style.cursor = 'text';
            grid.style.minHeight = '60vh';
            grid.addEventListener('click', (e) => {
                // Só adicionar se clicar na área vazia
                if (e.target === grid || e.target.classList.contains('mb-8')) {
                    addQuickTaskInputToday(grid, today);
                }
            });
        }

        function addQuickTaskInputToday(container, day) {
            // Verificar se já existe um input ativo
            const existingInput = container.querySelector('.quick-task-input');
            if (existingInput) {
                existingInput.focus();
                return;
            }

            const inputContainer = document.createElement('div');
            inputContainer.className = 'quick-task-container';

            // Checkbox placeholder
            const checkboxPlaceholder = document.createElement('div');
            checkboxPlaceholder.style.width = '18px';
            checkboxPlaceholder.style.height = '18px';
            checkboxPlaceholder.style.borderRadius = '6px';
            checkboxPlaceholder.style.border = '1.5px solid #555';
            checkboxPlaceholder.style.flexShrink = '0';
            checkboxPlaceholder.style.marginTop = '2px';
            inputContainer.appendChild(checkboxPlaceholder);

            // Input
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'quick-task-input';
            input.placeholder = 'Digite para adicionar tarefa...';
            input.autocomplete = 'off';
            input.setAttribute('data-form-type', 'other');
            inputContainer.appendChild(input);

            container.appendChild(inputContainer);
            input.focus();

            // Salvar ao pressionar Enter
            input.addEventListener('keydown', async (e) => {
                if (e.key === 'Enter' && input.value.trim()) {
                    e.preventDefault();

                    const dateStr = localDateStr();
                    const period = 'Tarefas';

                    if (!allTasksData[dateStr]) allTasksData[dateStr] = {};
                    if (!allTasksData[dateStr][period]) allTasksData[dateStr][period] = [];

                    const newTask = {
                        text: input.value.trim(),
                        completed: false,
                        color: 'default',
                        isHabit: false
                    };

                    allTasksData[dateStr][period].push(newTask);

                    await syncTaskToSupabase(dateStr, period, newTask);
                    saveToLocalStorage();

                    renderView();
                }

                // Deletar linha vazia ao pressionar Backspace/Delete
                if ((e.key === 'Backspace' || e.key === 'Delete') && input.value.trim() === '') {
                    e.preventDefault();
                    inputContainer.remove();
                }

                if (e.key === 'Escape') {
                    inputContainer.remove();
                }
            });

            input.addEventListener('blur', () => {
                setTimeout(() => {
                    if (!input.value.trim()) {
                        inputContainer.remove();
                    }
                }, 100);
            });
        }

        function addQuickTaskInput(column, day) {
            // Verificar se já existe um input ativo
            const existingInput = column.querySelector('.quick-task-input');
            if (existingInput) {
                existingInput.focus();
                return;
            }

            const container = document.createElement('div');
            container.className = 'quick-task-container';

            // Checkbox placeholder (desabilitado)
            const checkboxPlaceholder = document.createElement('div');
            checkboxPlaceholder.style.width = '18px';
            checkboxPlaceholder.style.height = '18px';
            checkboxPlaceholder.style.borderRadius = '6px';
            checkboxPlaceholder.style.border = '1.5px solid #555';
            checkboxPlaceholder.style.flexShrink = '0';
            checkboxPlaceholder.style.marginTop = '2px';
            container.appendChild(checkboxPlaceholder);

            // Input
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'quick-task-input';
            input.placeholder = 'Digite para adicionar tarefa...';
            input.autocomplete = 'off';
            input.setAttribute('data-form-type', 'other');
            container.appendChild(input);

            // Adicionar ao final da coluna
            column.appendChild(container);
            input.focus();

            // Salvar ao pressionar Enter
            input.addEventListener('keydown', async (e) => {
                if (e.key === 'Enter' && input.value.trim()) {
                    e.preventDefault();

                    // Encontrar a data correspondente ao dia da coluna
                    const weekDates = getWeekDates(currentWeekOffset);
                    const dayInfo = weekDates.find(d => d.name === day);
                    if (!dayInfo) return;

                    const dateStr = dayInfo.dateStr;
                    const period = 'Tarefas';

                    if (!allTasksData[dateStr]) allTasksData[dateStr] = {};
                    if (!allTasksData[dateStr][period]) allTasksData[dateStr][period] = [];

                    const newTask = {
                        text: input.value.trim(),
                        completed: false,
                        color: 'default',
                        isHabit: false
                    };

                    allTasksData[dateStr][period].push(newTask);

                    // Salvar e sincronizar
                    await syncTaskToSupabase(dateStr, period, newTask);
                    saveToLocalStorage();

                    // Re-renderizar a view
                    renderView();
                }

                // Deletar linha vazia ao pressionar Backspace/Delete
                if ((e.key === 'Backspace' || e.key === 'Delete') && input.value.trim() === '') {
                    e.preventDefault();
                    container.remove();
                }

                // Cancelar ao pressionar Escape
                if (e.key === 'Escape') {
                    container.remove();
                }
            });

            // Remover se perder o foco e estiver vazio
            input.addEventListener('blur', () => {
                setTimeout(() => {
                    if (!input.value.trim()) {
                        container.remove();
                    }
                }, 100);
            });
        }

        function createTaskElement(day, dateStr, period, task, index) {
            const container = document.createElement('div');

            // Top Drop Zone (não mostrar para recorrentes)
            if (index !== -1) container.appendChild(createDropZone(day, dateStr, period, index));

            const isRecurring = index === -1; // tarefas recorrentes não persistidas

            const el = document.createElement('div');
            el.className = `task-item ${task.isHabit ? 'is-habit' : ''}`;
            el.draggable = !isRecurring;
            el.dataset.day = day;
            el.dataset.date = dateStr;
            el.dataset.period = period;
            el.dataset.index = index;

            // Aplicar indent se existir
            if (task.indent && task.indent > 0) {
                el.style.paddingLeft = `${task.indent * 24}px`;
            }

            // Drag Handle (oculto para tarefas recorrentes)
            const handle = document.createElement('div');
            handle.className = 'drag-handle';
            handle.innerHTML = '⋮⋮';
            handle.style.cursor = isRecurring ? 'default' : 'pointer';
            if (isRecurring) handle.style.display = 'none';
            handle.addEventListener('click', (e) => {
                if (isRecurring) return;
                e.stopPropagation();
                e.preventDefault();
                showEditToolbar(e, task, label);
            });
            el.appendChild(handle);

            // Checkbox
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'checkbox-custom';
            checkbox.checked = task.completed;
            checkbox.onchange = (e) => {
                task.completed = e.target.checked;
                label.classList.toggle('task-completed', task.completed);


                // SOLUÇÃO: Atualizar diretamente no dailyRoutine se for tarefa de rotina
                if (task.isRoutine) {
                    const routineIndex = dailyRoutine.findIndex(t => t.text === task.text);
                    if (routineIndex !== -1) {
                        dailyRoutine[routineIndex].completed = task.completed;
                    }
                }


                // Sempre salvar
                saveToLocalStorage();

                // Habit logic
                if (task.isHabit) markHabitCompleted(task.text, task.completed);

                // Sincronizar com Supabase
                syncDateToSupabase(dateStr);
            }
            el.appendChild(checkbox);

            // Label
            const label = document.createElement('span');
            label.className = `task-label color-${task.color || 'default'} ${task.completed ? 'task-completed' : ''}`;
            // Aplicar cor azul se for tarefa de rotina
            if (task.isRoutine || period === 'Rotina') {
                label.style.color = 'var(--accent-blue)';
            }

            // Normalizar texto da tarefa (garantir que não seja undefined)
            if (task.text === undefined || task.text === null) {
                task.text = '';
            }

            // Se a tarefa está vazia, mostrar placeholder
            if (task.text.trim() === '') {
                label.textContent = '';
                label.style.color = '#666';
                label.setAttribute('data-placeholder', 'Clique para editar...');
                label.style.position = 'relative';
            } else {
                label.textContent = task.text;
            }

            // Single Click Edit
            label.onclick = (e) => {
                if (label.isContentEditable) return;
                startEditing(label, task, el);
            };

            // Context Menu
            label.oncontextmenu = (e) => {
                e.preventDefault();
                showEditToolbar(e, task, label);
            }

            el.appendChild(label);

            // Drag Events
            el.ondragstart = handleDragStart;
            el.ondragend = handleDragEnd;

            container.appendChild(el);
            return container;
        }

        function createDropZone(day, dateStr, period, index) {
            const dz = document.createElement('div');
            dz.className = 'task-drop-zone';
            dz.dataset.day = day;
            dz.dataset.date = dateStr;
            dz.dataset.period = period;
            dz.dataset.insertAt = index;

            dz.ondragover = (e) => { e.preventDefault(); dz.classList.add('show'); };
            dz.ondragleave = () => dz.classList.remove('show');
            dz.ondrop = (e) => handleDropZoneDrop(e, dz);
            return dz;
        }

        // --- Editing Logic ---

        function startEditing(label, task, taskDiv) {
            if (currentEditingTask) finishEditing();
            currentEditingTask = { label, task, original: task.text };

            label.contentEditable = true;
            label.focus();
            taskDiv.draggable = false;

            // Select all text
            const range = document.createRange();
            range.selectNodeContents(label);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);

            label.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finishEditing();
                }
                if (e.key === 'Escape') {
                    label.textContent = currentEditingTask.original;
                    finishEditing();
                }
                // Delete ou Backspace em tarefa vazia = deletar a tarefa
                if ((e.key === 'Backspace' || e.key === 'Delete') && label.textContent.trim() === '') {
                    e.preventDefault();
                    label.textContent = ''; // Garantir que está vazio
                    finishEditing(); // Vai deletar a tarefa automaticamente
                }
                // TAB para indent (estilo Notion)
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const taskItem = label.closest('.task-item');
                    const currentIndent = parseInt(task.indent || 0);

                    if (e.shiftKey) {
                        // Shift+Tab = desindentar
                        if (currentIndent > 0) {
                            task.indent = currentIndent - 1;
                            taskItem.style.paddingLeft = `${task.indent * 24}px`;
                        }
                    } else {
                        // Tab = indentar
                        if (currentIndent < 3) { // Máximo 3 níveis
                            task.indent = currentIndent + 1;
                            taskItem.style.paddingLeft = `${task.indent * 24}px`;
                        }
                    }

                    saveToLocalStorage();
                }
            };
            label.onblur = finishEditing;
        }

        async function finishEditing() {
            if (!currentEditingTask) return;
            const { label, task } = currentEditingTask;
            const newText = label.textContent.trim();

            // Se a tarefa ficou vazia, deletar
            if (!newText || newText === '') {
                const taskElement = label.closest('.task-item');
                const dateStr = taskElement.dataset.date;
                const period = taskElement.dataset.period;
                const index = parseInt(taskElement.dataset.index);

                if (allTasksData[dateStr] && allTasksData[dateStr][period]) {
                    const taskToDelete = allTasksData[dateStr][period][index];

                    // Deletar do Supabase
                    await deleteTaskFromSupabase(taskToDelete);

                    // Deletar localmente
                    allTasksData[dateStr][period].splice(index, 1);

                    // Limpar período vazio
                    if (allTasksData[dateStr][period].length === 0) {
                        delete allTasksData[dateStr][period];
                    }

                    // Limpar data vazia
                    if (Object.keys(allTasksData[dateStr]).length === 0) {
                        delete allTasksData[dateStr];
                    }
                }

                localStorage.setItem('allTasksData', JSON.stringify(allTasksData));
                currentEditingTask = null;
                renderView();
                return;
            }

            // Tarefa tem texto, salvar normalmente
            task.text = newText;
            label.contentEditable = false;
            label.closest('.task-item').draggable = true;

            // Remover placeholder se tinha
            if (label.hasAttribute('data-placeholder')) {
                label.removeAttribute('data-placeholder');
                label.style.color = '';
            }

            saveToLocalStorage();
            currentEditingTask = null;
        }

        function showTaskInput(btn, day, period) {
            const input = document.createElement('input');
            input.className = 'task-input';
            input.placeholder = 'Nova tarefa...';
            btn.replaceWith(input);
            input.focus();

            const save = () => {
                if (input.value.trim()) {
                    if (!weekData[day][period]) weekData[day][period] = [];
                    weekData[day][period].push({ text: input.value.trim(), completed: false, color: 'default', isHabit: false });
                    saveToLocalStorage();
                }
                renderView();
            };

            input.onkeydown = (e) => { if (e.key === 'Enter') save(); if (e.key === 'Escape') renderView(); };
            input.onblur = () => setTimeout(save, 100);
        }

        // --- Drag & Drop Handlers ---

        function handleDragStart(e) {
            const period = this.dataset.period;
            const dateStr = this.dataset.date;
            const index = parseInt(this.dataset.index);

            // Tarefas recorrentes (index = -1) não são arrastáveis
            if (index === -1) { e.preventDefault(); return; }

            // Usar allTasksData para buscar a tarefa
            const dayData = allTasksData[dateStr] || {};
            const task = (dayData[period] || [])[index];
            if (!task) { e.preventDefault(); return; }

            draggedTask = {
                day: this.dataset.day,
                dateStr: dateStr,
                period: period,
                index: index,
                task: task
            };

            document.body.classList.add('dragging-active');
            setTimeout(() => this.classList.add('opacity-50'), 0);
        }

        function handleDragEnd(e) {
            document.body.classList.remove('dragging-active');
            this.classList.remove('opacity-50');
            document.querySelectorAll('.day-column').forEach(c => c.classList.remove('drag-over'));
        }

        function handleDragOver(e) { e.preventDefault(); }

        function handleDropZoneDrop(e, dz) {
            e.stopPropagation();
            dz.classList.remove('show');
            if (!draggedTask) return;

            const targetDateStr = dz.dataset.date;
            const targetPeriod = dz.dataset.period;
            let insertAt = parseInt(dz.dataset.insertAt);

            const sourceDateStr = draggedTask.dateStr;
            const sourcePeriod = draggedTask.period;
            const sourceIndex = draggedTask.index;

            // Garantir que as estruturas existem
            if (!allTasksData[sourceDateStr]) allTasksData[sourceDateStr] = {};
            if (!allTasksData[targetDateStr]) allTasksData[targetDateStr] = {};
            if (!allTasksData[sourceDateStr][sourcePeriod]) allTasksData[sourceDateStr][sourcePeriod] = [];
            if (!allTasksData[targetDateStr][targetPeriod]) allTasksData[targetDateStr][targetPeriod] = [];

            // Remover da posição antiga
            allTasksData[sourceDateStr][sourcePeriod].splice(sourceIndex, 1);

            // Ajustar index se for a mesma lista
            if (sourceDateStr === targetDateStr && sourcePeriod === targetPeriod && sourceIndex < insertAt) {
                insertAt--;
            }

            // Ajustar a flag isRoutine baseado no período de destino
            const taskToMove = { ...draggedTask.task };
            if (targetPeriod === 'Rotina') {
                taskToMove.isRoutine = true;
            } else {
                taskToMove.isRoutine = false;
            }

            // Inserir na nova posição
            allTasksData[targetDateStr][targetPeriod].splice(insertAt, 0, taskToMove);

            // Limpar períodos vazios
            if (allTasksData[sourceDateStr][sourcePeriod].length === 0) {
                delete allTasksData[sourceDateStr][sourcePeriod];
            }

            // Salvar localmente
            localStorage.setItem('allTasksData', JSON.stringify(allTasksData));

            // Sincronizar dias afetados com Supabase (mantém a ordem)
            const datesToSync = [...new Set([sourceDateStr, targetDateStr])];
            (async () => { for (const d of datesToSync) await syncDateToSupabase(d); })();

            renderView();
            draggedTask = null;
        }

        // Sincroniza todas as tarefas de uma data com o Supabase, preservando a ordem
        async function syncDateToSupabase(dateStr) {
            if (!currentUser) return;
            _isSyncingDate = true;
            try {

                // Deletar todos os registros desta data no Supabase
                await supabaseClient.from('tasks').delete()
                    .eq('user_id', currentUser.id)
                    .eq('day', dateStr);

                // Reinserir na ordem atual do allTasksData
                // Nunca salvar tarefas recorrentes ou de rotina no banco
                const weeklyTextsSet = new Set(weeklyRecurringTasks.map(rt => rt.text));
                const routineTextsSet = new Set(dailyRoutine.map(rt => rt.text));
                const periods = allTasksData[dateStr] || {};
                const inserts = [];
                Object.entries(periods).forEach(([period, tasks]) => {
                    if (Array.isArray(tasks)) {
                        tasks.forEach(task => {
                            if (!task.text || task.text.trim() === '') return;
                            if (task.isWeeklyRecurring || task.isRoutine) return;
                            if (weeklyTextsSet.has(task.text) || routineTextsSet.has(task.text)) return;
                            inserts.push({
                                user_id: currentUser.id,
                                day: dateStr,
                                period: period,
                                text: task.text,
                                completed: task.completed || false,
                                color: task.color || 'default',
                                is_habit: task.isHabit || false
                            });
                        });
                    }
                });

                if (inserts.length > 0) {
                    const { data } = await supabaseClient.from('tasks').insert(inserts).select();
                    // Atualizar supabaseIds locais
                    if (data) {
                        data.forEach((row) => {
                            const tasks = allTasksData[row.day]?.[row.period];
                            if (tasks) {
                                const match = tasks.find(t => t.text === row.text && !t.supabaseId);
                                if (match) match.supabaseId = row.id;
                            }
                        });
                        localStorage.setItem('allTasksData', JSON.stringify(allTasksData));
                    }
                }
            } finally {
                _isSyncingDate = false;
            }
        }

        function handleDrop(e) {
            // Fallback drop on column
            e.preventDefault();
            // Logic to drop at end of list if dropped on column
        }

        // --- Menus ---
        function showEditToolbar(e, task, label) {
            const toolbar = document.getElementById('editToolbar');
            toolbar.style.left = e.pageX + 'px';
            toolbar.style.top = e.pageY + 'px';
            toolbar.classList.add('show');

            // Setup buttons (simplified)
            toolbar.querySelector('[data-action="color"]').onclick = (ev) => {
                ev.stopPropagation();
                showColorMenu(ev, task, label);
            }
            toolbar.querySelector('[data-action="habit"]').onclick = () => {
                task.isHabit = !task.isHabit;

                if (task.isHabit) {
                    // Verificar se já existe na rotina
                    const alreadyInRoutine = dailyRoutine.some(t => t.text === task.text);

                    if (!alreadyInRoutine) {
                        // Adicionar à rotina diária
                        dailyRoutine.push({
                            text: task.text,
                            completed: false,
                            color: task.color || 'default',
                            isHabit: true
                        });
                        localStorage.setItem('dailyRoutine', JSON.stringify(dailyRoutine));
                    }

                    alert(`"${task.text}" marcado como hábito e adicionado à Rotina!`);
                } else {
                    // Remover da rotina diária
                    const routineIndex = dailyRoutine.findIndex(t => t.text === task.text);
                    if (routineIndex !== -1) {
                        dailyRoutine.splice(routineIndex, 1);
                        localStorage.setItem('dailyRoutine', JSON.stringify(dailyRoutine));
                    }
                    alert(`"${task.text}" removido dos hábitos e da Rotina.`);
                }

                saveToLocalStorage();
                renderView();
                toolbar.classList.remove('show');
            }
            toolbar.querySelector('[data-action="delete"]').onclick = async () => {
                // Delete logic
                const taskElement = label.closest('.task-item');
                const dateStr = taskElement.dataset.date;
                const period = taskElement.dataset.period;
                const index = parseInt(taskElement.dataset.index);

                // Buscar a tarefa
                if (!allTasksData[dateStr] || !allTasksData[dateStr][period]) return;
                const taskToDelete = allTasksData[dateStr][period][index];

                // Deletar do Supabase primeiro
                await deleteTaskFromSupabase(taskToDelete);

                // Depois deletar localmente
                allTasksData[dateStr][period].splice(index, 1);

                // Limpar período vazio
                if (allTasksData[dateStr][period].length === 0) {
                    delete allTasksData[dateStr][period];
                }

                localStorage.setItem('allTasksData', JSON.stringify(allTasksData));
                renderView();
            }
        }

        function showColorMenu(e, task, label) {
            const menu = document.getElementById('colorMenu');
            const rect = document.getElementById('editToolbar').getBoundingClientRect();
            // Fix positioning (scroll aware)
            const scrollLeft = window.scrollX || document.documentElement.scrollLeft;
            const scrollTop = window.scrollY || document.documentElement.scrollTop;

            menu.style.left = (rect.left + scrollLeft) + 'px';
            menu.style.top = (rect.bottom + scrollTop + 8) + 'px';
            menu.classList.add('show');

            menu.querySelectorAll('.color-swatch').forEach(s => {
                s.onclick = () => {
                    const color = s.dataset.color;
                    task.color = color;
                    saveToLocalStorage();
                    renderView();
                }
            });
        }

        // --- Init ---
        document.addEventListener('click', (e) => {
            if (!e.target.closest('#editToolbar') && !e.target.closest('#colorMenu')) {
                document.getElementById('editToolbar').classList.remove('show');
                document.getElementById('colorMenu').classList.remove('show');
            }
            if (!e.target.closest('#userDropdown') && !e.target.closest('#btnUser')) {
                document.getElementById('userDropdown').classList.remove('show');
            }
        });

        document.getElementById('btnUser').onclick = () => {
            const drop = document.getElementById('userDropdown');
            drop.style.display = drop.style.display === 'flex' ? 'none' : 'flex';
        };

        document.getElementById('btnLogout').onclick = signOut;

        document.getElementById('btnTogglePeriods').onclick = () => {
            const current = localStorage.getItem('showPeriods') !== 'false';
            localStorage.setItem('showPeriods', (!current).toString());
            renderView();
        };

        document.getElementById('floatingAddBtn').onclick = () => {
            const m = document.getElementById('quickAddMenu');
            m.style.display = m.style.display === 'flex' ? 'none' : 'flex';
        }

        // Event listeners para opções do quick add menu
        document.querySelectorAll('.quick-add-option').forEach(option => {
            option.onclick = () => {
                const type = option.dataset.type;
                document.getElementById('quickAddMenu').style.display = 'none';

                if (type === 'routine') {
                    const text = prompt('Digite a tarefa de rotina diária:');
                    if (text && text.trim()) {
                        dailyRoutine.push({
                            text: text.trim(),
                            completed: false,
                            color: 'default',
                            isHabit: true
                        });
                        localStorage.setItem('dailyRoutine', JSON.stringify(dailyRoutine));
                        renderView();
                    }
                } else if (type === 'weekly') {
                    showWeeklyRecurrenceDialog();
                } else if (type === 'custom') {
                    // Abre um prompt para tarefa customizada (ex: adicionar em data específica)
                    const text = prompt('Digite a tarefa:');
                    if (text && text.trim()) {
                        const dateStr = localDateStr();
                        const period = 'Tarefas';

                        if (!allTasksData[dateStr]) allTasksData[dateStr] = {};
                        if (!allTasksData[dateStr][period]) allTasksData[dateStr][period] = [];

                        const newTask = {
                            text: text.trim(),
                            completed: false,
                            color: 'default',
                            isHabit: false
                        };

                        allTasksData[dateStr][period].push(newTask);
                        syncTaskToSupabase(dateStr, period, newTask);
                        saveToLocalStorage();
                        renderView();
                    }
                }
            };
        });

        // Event listeners para autenticação
        document.getElementById('btnLogin').onclick = async () => {
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            await signIn(email, password);
        };

        document.getElementById('btnSignup').onclick = async () => {
            const email = document.getElementById('signupEmail').value;
            const password = document.getElementById('signupPassword').value;
            await signUp(email, password);
        };

        document.getElementById('btnShowSignup').onclick = () => {
            document.getElementById('authLogin').style.display = 'none';
            document.getElementById('authSignup').style.display = 'block';
        };

        document.getElementById('btnShowLogin').onclick = () => {
            document.getElementById('authSignup').style.display = 'none';
            document.getElementById('authLogin').style.display = 'block';
        };

        // Event listeners do modal de tarefa semanal
        document.querySelectorAll('.weekly-day-btn').forEach(btn => {
            btn.onclick = () => btn.classList.toggle('selected');
        });

        document.getElementById('weeklyTaskText').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') document.getElementById('btnSaveWeekly').click();
            if (e.key === 'Escape') document.getElementById('btnCancelWeekly').click();
        });

        document.getElementById('btnSaveWeekly').onclick = () => {
            const text = document.getElementById('weeklyTaskText').value.trim();
            if (!text) {
                document.getElementById('weeklyTaskText').focus();
                return;
            }

            const selectedDays = [...document.querySelectorAll('.weekly-day-btn.selected')]
                .map(b => parseInt(b.dataset.day));

            if (selectedDays.length === 0) {
                // Destacar os botões visualmente para indicar que precisa selecionar
                document.querySelectorAll('.weekly-day-btn').forEach(b => {
                    b.style.borderColor = '#ff453a';
                    setTimeout(() => b.style.borderColor = '', 1000);
                });
                return;
            }

            weeklyRecurringTasks.push({
                text,
                daysOfWeek: selectedDays,
                color: 'default',
                isHabit: false
            });

            localStorage.setItem('weeklyRecurringTasks', JSON.stringify(weeklyRecurringTasks));
            document.getElementById('weeklyModal').classList.remove('show');

            if (currentView === 'settings') renderSettingsView();
            if (currentView === 'routine') renderRoutineView();
            else renderView();
        };

        document.getElementById('btnCancelWeekly').onclick = () => {
            document.getElementById('weeklyModal').classList.remove('show');
        };

        // Handlers de export/import/clear estão dentro de renderSettingsView()

        // Normalizar tarefas (corrigir text: undefined e remover recorrentes/rotina persistidas)
        function normalizeAllTasks() {
            let hasChanges = false;
            const weeklyTextsSet = new Set(weeklyRecurringTasks.map(rt => rt.text));
            const routineTextsSet = new Set(dailyRoutine.map(rt => rt.text));

            Object.entries(allTasksData).forEach(([dateStr, periods]) => {
                // Remover completamente o período 'Rotina' se existir (nunca deve ser persistido)
                if (periods['Rotina']) {
                    delete periods['Rotina'];
                    hasChanges = true;
                }

                Object.entries(periods).forEach(([period, tasks]) => {
                    if (Array.isArray(tasks)) {
                        // Remover tarefas recorrentes/rotina salvas indevidamente (por flag ou por texto)
                        const filtered = tasks.filter(task => {
                            if (task.isWeeklyRecurring || task.isRoutine) return false;
                            if (task.text && weeklyTextsSet.has(task.text)) return false;
                            return true;
                        });
                        if (filtered.length !== tasks.length) {
                            allTasksData[dateStr][period] = filtered;
                            hasChanges = true;
                        }
                        allTasksData[dateStr][period].forEach(task => {
                            if (task.text === undefined || task.text === null) {
                                task.text = '';
                                hasChanges = true;
                            }
                        });
                        // Limpar período vazio
                        if (allTasksData[dateStr][period].length === 0) {
                            delete allTasksData[dateStr][period];
                            hasChanges = true;
                        }
                    }
                });
                // Limpar data vazia
                if (Object.keys(allTasksData[dateStr] || {}).length === 0) {
                    delete allTasksData[dateStr];
                    hasChanges = true;
                }
            });

            if (hasChanges) {
                localStorage.setItem('allTasksData', JSON.stringify(allTasksData));
            }
        }

        loadFromLocalStorage();
        normalizeAllTasks(); // Normalizar tarefas antigas
        // checkAuth agora é chamado via onAuthStateChange (INITIAL_SESSION)
        // setTimeout(checkAuth, 100);

        // Inicializar ícones Lucide
        lucide.createIcons();

        // ========================================
        // PWA - Service Worker & Notificações
        // ========================================

        let serviceWorkerRegistration = null;

        // Registrar Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/service-worker.js')
                .then((registration) => {
                    console.log('✅ Service Worker registrado:', registration);
                    serviceWorkerRegistration = registration;

                    // Pedir permissão para notificações após 3 segundos
                    setTimeout(() => {
                        requestNotificationPermission();
                    }, 3000);
                })
                .catch((error) => {
                    console.error('❌ Erro ao registrar Service Worker:', error);
                });

            // Listener para mensagens do Service Worker
            navigator.serviceWorker.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'GET_DAILY_STATS') {
                    sendDailyStats();
                }
            });
        }

        // Função para pedir permissão de notificações
        async function requestNotificationPermission() {
            if (!('Notification' in window)) {
                console.log('Este navegador não suporta notificações');
                return;
            }

            if (Notification.permission === 'granted') {
                console.log('✅ Permissão de notificações já concedida');
                scheduleNotifications();
                return;
            }

            if (Notification.permission !== 'denied') {
                const permission = await Notification.requestPermission();
                if (permission === 'granted') {
                    console.log('✅ Permissão de notificações concedida!');
                    scheduleNotifications();
                    showWelcomeNotification();
                }
            }
        }

        // Agendar notificações através do Service Worker
        function scheduleNotifications() {
            if (serviceWorkerRegistration) {
                const notifSettings = JSON.parse(localStorage.getItem('flowly_notif_settings') || '{}');
                serviceWorkerRegistration.active.postMessage({
                    type: 'SCHEDULE_NOTIFICATIONS',
                    morningTime: notifSettings.morningTime || '08:00',
                    eveningTime: notifSettings.eveningTime || '21:00'
                });
            }
        }

        // Notificação de boas-vindas
        function showWelcomeNotification() {
            if (serviceWorkerRegistration) {
                serviceWorkerRegistration.showNotification('🎉 Notificações ativadas!', {
                    body: 'Você receberá lembretes e atualizações de progresso',
                    icon: '/logo_flowly.png',
                    badge: '/logo_flowly.png',
                    vibrate: [200, 100, 200],
                    tag: 'flowly-welcome'
                });
            }
        }

        // Enviar notificação de progresso
        function sendProgressNotification() {
            const today = localDateStr();
            const dayData = allTasksData[today] || {};

            let total = 0;
            let completed = 0;

            Object.values(dayData).forEach(period => {
                if (Array.isArray(period)) {
                    total += period.length;
                    completed += period.filter(t => t.completed).length;
                }
            });

            const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;

            if (serviceWorkerRegistration && total > 0) {
                serviceWorkerRegistration.active.postMessage({
                    type: 'SEND_PROGRESS_NOTIFICATION',
                    completed,
                    total,
                    percentage
                });
            }
        }

        // Enviar estatísticas diárias para o resumo da noite
        function sendDailyStats() {
            const today = localDateStr();
            const dayData = allTasksData[today] || {};

            let total = 0;
            let completed = 0;

            Object.values(dayData).forEach(period => {
                if (Array.isArray(period)) {
                    total += period.length;
                    completed += period.filter(t => t.completed).length;
                }
            });

            const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;

            if (serviceWorkerRegistration) {
                serviceWorkerRegistration.active.postMessage({
                    type: 'DAILY_STATS',
                    completed,
                    total,
                    percentage
                });
            }
        }

        // Enviar notificação de progresso quando tarefa é marcada
        const originalSaveToLocalStorage = saveToLocalStorage;
        saveToLocalStorage = function () {
            originalSaveToLocalStorage();

            // Enviar notificação a cada 3 tarefas completadas
            const today = localDateStr();
            const dayData = allTasksData[today] || {};
            let completed = 0;
            Object.values(dayData).forEach(period => {
                if (Array.isArray(period)) {
                    completed += period.filter(t => t.completed).length;
                }
            });

            // Notificar a cada 3, 5, 8 e 10 tarefas completadas
            if ([3, 5, 8, 10].includes(completed)) {
                setTimeout(sendProgressNotification, 1000);
            }
        };

        // ========================================
        // Fim PWA
        // ========================================

    </script>
</body>

</html>